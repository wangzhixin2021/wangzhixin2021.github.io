<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"base16/onedark","dark":"base16/onedark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true,"highlight":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="我们在写网络编程时，经常使用socket函数，而socket函数内部的实现原理究竟为何？到底做了哪些事情呢？本篇主要聚焦介绍此问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="socket系统调用">
<meta property="og:url" content="http://example.com/2025/12/13/socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/index.html">
<meta property="og:site_name" content="积硅步，至千里">
<meta property="og:description" content="我们在写网络编程时，经常使用socket函数，而socket函数内部的实现原理究竟为何？到底做了哪些事情呢？本篇主要聚焦介绍此问题。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-13T05:08:27.000Z">
<meta property="article:modified_time" content="2026-01-05T14:36:34.204Z">
<meta property="article:author" content="wangzhixin">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/12/13/socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/12/13/socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","path":"2025/12/13/socket系统调用/","title":"socket系统调用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>socket系统调用 | 积硅步，至千里</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">积硅步，至千里</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#glibc-socket%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">glibc socket函数介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">socket系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzhixin</p>
  <div class="site-description" itemprop="description">Linux C/C++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/13/socket%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhixin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积硅步，至千里">
      <meta itemprop="description" content="Linux C/C++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="socket系统调用 | 积硅步，至千里">
      <meta itemprop="description" content="我们在写网络编程时，经常使用socket函数，而socket函数内部的实现原理究竟为何？到底做了哪些事情呢？本篇主要聚焦介绍此问题。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          socket系统调用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-13 13:08:27" itemprop="dateCreated datePublished" datetime="2025-12-13T13:08:27+08:00">2025-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-05 22:36:34" itemprop="dateModified" datetime="2026-01-05T22:36:34+08:00">2026-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux6-6%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">linux6.6内核</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">我们在写网络编程时，经常使用socket函数，而socket函数内部的实现原理究竟为何？到底做了哪些事情呢？本篇主要聚焦介绍此问题。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="glibc-socket函数介绍"><a href="#glibc-socket函数介绍" class="headerlink" title="glibc socket函数介绍"></a>glibc socket函数介绍</h2><p>我们使用的socket函数，原型如下。<br>头文件位置为：&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;socket.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span> __THROW;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>__domain</td>
<td>指定一个通讯域名；选择的协议将会用于通讯。如 AF_INET、AF_NETLINK、AF_PACKET、AF_UNIX</td>
</tr>
<tr>
<td>__type</td>
<td>套接字通过 type, 参数来确定通信语义。如：SOCK_STREAM、SOCK_DGRAM、SOCK_RAW</td>
</tr>
<tr>
<td>__protocol</td>
<td>指定一个协议用于套接字。如 IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP、IPPROTO_IP</td>
</tr>
</tbody></table>
<hr>
<p>而socket函数是glibc中提供的函数，我们看下glibc中的socket函数实现。<br>代码位置在：glibc-2.41&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;socket.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;socketcall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__socket (<span class="type">int</span> fd, <span class="type">int</span> type, <span class="type">int</span> domain)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSUME_SOCKET_SYSCALL</span></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL_CALL (socket, fd, type, domain);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> SOCKETCALL (socket, fd, type, domain);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__socket)</span><br><span class="line">weak_alias (__socket, socket)</span><br></pre></td></tr></table></figure>

<p>可以看到，glibc中的socket函数几乎什么都没做，可以理解为仅仅是内核socket系统调用(__do_sys_socket)的一个封装，中间的步骤在<a target="_blank" rel="noopener" href="https://wangzhixin2021.github.io/2025/12/09/syscall%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">syscall调用流程分析</a>中有做展开讲解，这里不再赘述。</p>
<h2 id="socket系统调用"><a href="#socket系统调用" class="headerlink" title="socket系统调用"></a>socket系统调用</h2><p>我们首先来看下socket系统调用的入口。可以看到__do_sys_socket，什么都没做，只是再次调用了__sys_socket。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* __do_sys_socket */</span></span><br><span class="line">SYSCALL_DEFINE3(socket, <span class="type">int</span>, family, <span class="type">int</span>, type, <span class="type">int</span>, protocol)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_socket(family, type, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>从__sys_socket中可以看到，主要调用了__sys_socket_create与sock_map_fd函数。有一些额外的NONBLOCK兼容处理。__sys_socket_create就是申请了一个socket_alloc结构，返回其中的socket结构。然后调用sock_map_fd将socket映射出一个fd。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 只由 __x64_sys_socket 、 __x64_sys_socketcall 调用 </span></span><br><span class="line"><span class="comment"> * 负责根据传入的三个参数，创建出 socket_alloc 结构，并映射出fd返给外围 */</span></span><br><span class="line"><span class="type">int</span> __sys_socket(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 用于指向申请的socket_alloc中的socket */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请 socket_alloc 结构，并初始化，但是注意这里返回的只是其中的socket */</span></span><br><span class="line">	sock = __sys_socket_create(family, type,</span><br><span class="line">				   update_socket_protocol(family, type, protocol));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sock))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(sock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 不关心 低4bit sock的type，取出其高位数据，</span></span><br><span class="line"><span class="comment">	 * 高位看起来应该只能是 SOCK_NONBLOCK 或 SOCK_CLOEXEC */</span></span><br><span class="line">	flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK)) &#123;</span><br><span class="line">		<span class="comment">/* 把 socket 层的非阻塞标志 统一转换成 文件描述符层的非阻塞标志 *</span></span><br><span class="line"><span class="comment">		 * 将 SOCK_NONBLOCK 清位之后，再将 O_NONBLOCK 置位 */</span></span><br><span class="line">		flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将 socket 映射出一个对应的文件描述符fd，返给上层应用 */</span></span><br><span class="line">	<span class="keyword">return</span> sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>我们先看__sys_socket_create做了什么。可以看到，只是做了下编译器一致性检查，及标志位校验等，从type中提取出真正的类型(高位有可能有其它标志置位了)，然后调用sock_create。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 __sys_socket 调用 </span></span><br><span class="line"><span class="comment"> * 负责创建出 socket_alloc 结构 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *__<span class="title">sys_socket_create</span>(<span class="title">int</span> <span class="title">family</span>, <span class="title">int</span> <span class="title">type</span>, <span class="title">int</span> <span class="title">protocol</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the SOCK_* constants for consistency.  </span></span><br><span class="line"><span class="comment">	 * 编译器一致性检查 */</span></span><br><span class="line">	BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);</span><br><span class="line">	BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);</span><br><span class="line">	BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);</span><br><span class="line">	BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 标志位校验 */</span></span><br><span class="line">	<span class="keyword">if</span> ((type &amp; ~SOCK_TYPE_MASK) &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取真正的类型，我们只关心它的低位的4bit */</span></span><br><span class="line">	type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">	retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这里sock_create仅是封装了下__sock_create。<br>__sock_create中有对family和type的合法性检查，有对过时的 PF_INET + SOCK_PACKET 参数组合 转换为 现代支持的 PF_PACKET 协议族。有过lsm相关的钩子点。<br>核心的是sock_alloc、及pf-&gt;create(对于AF_INET，就是inet_create)。这里面将申请socket_alloc结构，并且初始化。还会根据family、type申请对应的核心的sock结构，比如tcp_sock、udp_sock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_create</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="keyword">struct</span> socket **res)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line">			 <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Check protocol is in range</span></span><br><span class="line"><span class="comment">	 *      合法性检查</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (family &lt; <span class="number">0</span> || family &gt;= NPROTO)</span><br><span class="line">		<span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line">	<span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= SOCK_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compatibility.</span></span><br><span class="line"><span class="comment">	   This uglymoron is moved from INET layer to here to avoid deadlock in module load.</span></span><br><span class="line"><span class="comment">	   过时的 PF_INET + SOCK_PACKET 参数组合 转换为 现代支持的 PF_PACKET 协议族</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;</span><br><span class="line">		pr_info_once(<span class="string">&quot;%s uses obsolete (PF_INET,SOCK_PACKET)\n&quot;</span>,</span><br><span class="line">			     current-&gt;comm);</span><br><span class="line">		family = PF_PACKET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lsm socket_create hook点 */</span></span><br><span class="line">	err = security_socket_create(family, type, protocol, kern);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Allocate the socket and allow the family to set things up. if</span></span><br><span class="line"><span class="comment">	 *	the protocol is 0, the family is instructed to select an appropriate</span></span><br><span class="line"><span class="comment">	 *	default.</span></span><br><span class="line"><span class="comment">	 *  申请 socket_alloc 结构，返回的是其中的 socket 成员地址，</span></span><br><span class="line"><span class="comment">	 *  这里 socket-&gt;sk 还没初始化，是在底下的 pf-&gt;create 里面创建的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sock = sock_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!sock) &#123;</span><br><span class="line">		net_warn_ratelimited(<span class="string">&quot;socket: no more sockets\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENFILE;	<span class="comment">/* Not exactly a match, but its the</span></span><br><span class="line"><span class="comment">				   closest posix thing */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 这里的type是用户创建socket传入的第二参数的type */</span></span><br><span class="line">	sock-&gt;type = type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">	<span class="comment">/* Attempt to load a protocol module if the find failed.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user</span></span><br><span class="line"><span class="comment">	 * requested real, full-featured networking support upon configuration.</span></span><br><span class="line"><span class="comment">	 * Otherwise module support will break!</span></span><br><span class="line"><span class="comment">	 * net_families 存储的是 AF_INET 对应的 net_proto_family</span></span><br><span class="line"><span class="comment">	 * 是在 inet_init 中，通过 sock_register 注册的 inet_family_ops</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rcu_access_pointer(net_families[family]) == <span class="literal">NULL</span>)</span><br><span class="line">		request_module(<span class="string">&quot;net-pf-%d&quot;</span>, family);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从sock_register数组中找到一个元素pf，这个pf中有一个create()回调函数，</span></span><br><span class="line"><span class="comment">	 * 这个回调函数就是family类型(such as AF_INET)需要的create函数。 */</span></span><br><span class="line">	pf = rcu_dereference(net_families[family]);</span><br><span class="line">	err = -EAFNOSUPPORT;</span><br><span class="line">	<span class="keyword">if</span> (!pf)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment">	 * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment">	 * 增加引用计数，有些family可能是以模块方式加载的，比如 nf_conntrack</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* inet_create 、 inet6_create </span></span><br><span class="line"><span class="comment">	 * 如果用户指定的family类型是AF_INET, 那这个函数就是调用的inet_create，</span></span><br><span class="line"><span class="comment">	 * 这里面将真正的创建 socket-&gt;sk，并且给 socket 的部分成员初始化 */</span></span><br><span class="line">	err = pf-&gt;create(net, sock, protocol, kern);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_module_put;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now to bump the refcnt of the [loadable] module that owns this</span></span><br><span class="line"><span class="comment">	 * socket at sock_release time we decrement its refcnt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(sock-&gt;ops-&gt;owner))</span><br><span class="line">		<span class="keyword">goto</span> out_module_busy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now that we&#x27;re done with the -&gt;create function, the [loadable]</span></span><br><span class="line"><span class="comment">	 * module can have its refcnt decremented</span></span><br><span class="line"><span class="comment">	 * 减引用计数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(pf-&gt;owner);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lsm socket_post_create hook点 */</span></span><br><span class="line">	err = security_socket_post_create(sock, family, type, protocol, kern);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">	*res = sock;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_module_busy:</span><br><span class="line">	err = -EAFNOSUPPORT;</span><br><span class="line">out_module_put:</span><br><span class="line">	sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	module_put(pf-&gt;owner);</span><br><span class="line">out_sock_release:</span><br><span class="line">	sock_release(sock);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_release:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">goto</span> out_sock_release;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>sock_alloc函数就是申请了一个socket_alloc的结构，只是返回的是其中的socket地址。socket和inode是相邻的，可以通过SOCKET_I、SOCK_INODE之类的函数互相找到彼此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket *<span class="title function_">sock_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用socket文件系统的超级块的ops申请一个inode，申请的其实是 socket_alloc 结构 */</span></span><br><span class="line">	inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb);</span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过 container_of 取与 inode 相邻的 socket 地址 */</span></span><br><span class="line">	sock = SOCKET_I(inode);</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_ino = get_next_ino(); <span class="comment">/* 分配唯一的inode编号 */</span></span><br><span class="line">	inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO; <span class="comment">/* 文件类型 */</span></span><br><span class="line">	inode-&gt;i_uid = current_fsuid();</span><br><span class="line">	inode-&gt;i_gid = current_fsgid();</span><br><span class="line">	inode-&gt;i_op = &amp;sockfs_inode_ops; <span class="comment">/* 绑定ops */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">new_inode_pseudo</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> alloc_inode(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode) &#123;</span><br><span class="line">		spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">		inode-&gt;i_state = <span class="number">0</span>;</span><br><span class="line">		spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由 new_inode_pseudo 调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">alloc_inode</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">ops</span> =</span> sb-&gt;s_op;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于socket来说，调用的是 sockfs_ops 的 sock_alloc_inode</span></span><br><span class="line"><span class="comment">	 * sock_alloc_inode 会创建真正的 socket_alloc 结构 */</span></span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;alloc_inode)</span><br><span class="line">		inode = ops-&gt;alloc_inode(sb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		inode = alloc_inode_sb(sb, inode_cachep, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(inode_init_always(sb, inode))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ops-&gt;destroy_inode) &#123;</span><br><span class="line">			ops-&gt;destroy_inode(inode);</span><br><span class="line">			<span class="keyword">if</span> (!ops-&gt;free_inode)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;free_inode = ops-&gt;free_inode;</span><br><span class="line">		i_callback(&amp;inode-&gt;i_rcu);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由 alloc_inode 调用 </span></span><br><span class="line"><span class="comment"> * 申请socket_alloc结构，并初始化成员 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">sock_alloc_inode</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> *<span class="title">ei</span>;</span></span><br><span class="line"></span><br><span class="line">	ei = alloc_inode_sb(sb, sock_inode_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ei)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化等待队列 */</span></span><br><span class="line">	init_waitqueue_head(&amp;ei-&gt;socket.wq.wait);</span><br><span class="line">	ei-&gt;socket.wq.fasync_list = <span class="literal">NULL</span>;</span><br><span class="line">	ei-&gt;socket.wq.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ei-&gt;socket.state = SS_UNCONNECTED;</span><br><span class="line">	ei-&gt;socket.flags = <span class="number">0</span>;</span><br><span class="line">	ei-&gt;socket.ops = <span class="literal">NULL</span>;</span><br><span class="line">	ei-&gt;socket.sk = <span class="literal">NULL</span>;</span><br><span class="line">	ei-&gt;socket.file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ei-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>socket_alloc结构、SOCKET_I、SOCK_INODE 如下所示。使用container_of来找到彼此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sock_alloc_inode 申请并初始化 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> socket *<span class="title function_">SOCKET_I</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;container_of(inode, <span class="keyword">struct</span> socket_alloc, vfs_inode)-&gt;socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> inode *<span class="title function_">SOCK_INODE</span><span class="params">(<span class="keyword">struct</span> socket *socket)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;container_of(socket, <span class="keyword">struct</span> socket_alloc, socket)-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>socket结构如下所示。其中最为核心的是sock结构。对于tcp来说，它其实指向的是tcp_sock，对于udp来说，指向的是udp_sock。pf-&gt;create就是根据type和protocol，来创建对应的sock结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">	<span class="comment">/* such as SS_UNCONNECTED  、 SS_CONNECTED */</span></span><br><span class="line">	socket_state		state;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* socket()的第二个参数， __sock_create 中赋值， SOCK_STREAM 、 SOCK_DGRAM 、 SOCK_RAW 等*/</span></span><br><span class="line">	<span class="type">short</span>			type;	</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sock_alloc_file 中申请、初始化，并赋值 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>		*<span class="title">file</span>;</span>		</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* inet_create 中申请，申请的大小为 prot-&gt;obj_size</span></span><br><span class="line"><span class="comment">	 * sock_init_data_uid 中赋值，指向type对应申请出来的sock结构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk</span>;</span>		</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Might change with IPV6_ADDRFORM or MPTCP. </span></span><br><span class="line"><span class="comment">	 * 套接口层操作集合, such as inet_stream_ops 、 inet_dgram_ops、 inet_sockraw_ops */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>	*<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span>	<span class="title">wq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>inet_create是socket系统调用中的核心函数，它将创建并初始化socket结构中的最核心的、最关键的sock结构。是根据传入的type，从inetsw链表数组上，选取type对应的链表，再匹配最合适的协议，找到它对应的prot结构。通过prot-&gt;obj_size 来决定申请 sock 的内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create an inet socket.</span></span><br><span class="line"><span class="comment"> *  由 __sock_create 调用，</span></span><br><span class="line"><span class="comment"> *  这里主要是做 socket-&gt;sk 的创建，及 socket 的部分成员的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">		       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line">	<span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 协议有效性校验 */</span></span><br><span class="line">	<span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 正在创建socket，因此此时状态还是未连接 */</span></span><br><span class="line">	sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">	err = -ESOCKTNOSUPPORT;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="comment">/* 其实就是把 inetsw_array 中的成员，根据 type 挂在了 inetsw 的链表上 */</span></span><br><span class="line">	list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">				protocol = answer-&gt;protocol;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (try_loading_module &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Be more specific, e.g. net-pf-2-proto-132-type-1</span></span><br><span class="line"><span class="comment">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (++try_loading_module == <span class="number">1</span>)</span><br><span class="line">				request_module(<span class="string">&quot;net-pf-%d-proto-%d-type-%d&quot;</span>,</span><br><span class="line">					       PF_INET, protocol, sock-&gt;type);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Fall back to generic, e.g. net-pf-2-proto-132</span></span><br><span class="line"><span class="comment">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				request_module(<span class="string">&quot;net-pf-%d-proto-%d&quot;</span>,</span><br><span class="line">					       PF_INET, protocol);</span><br><span class="line">			<span class="keyword">goto</span> lookup_protocol;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -EPERM;</span><br><span class="line">	<span class="comment">/* 如果是用户态来创建的，并且是SOCK_RAW，额外检查下权限 */</span></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp;</span><br><span class="line">	    !ns_capable(net-&gt;user_ns, CAP_NET_RAW))</span><br><span class="line">		<span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* such as inet_stream_ops 、 inet_dgram_ops、 inet_sockraw_ops */</span></span><br><span class="line">	sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">	<span class="comment">/* such as tcp_prot 、 udp_prot 、ping_prot 、raw_prot */</span></span><br><span class="line">	answer_prot = answer-&gt;prot;</span><br><span class="line">	<span class="comment">/* see inetsw_array */</span></span><br><span class="line">	answer_flags = answer-&gt;flags;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	WARN_ON(!answer_prot-&gt;slab);</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="comment">/* 根据 prot-&gt;obj_size 来申请 sock 的内存, sk 其实就是 tcp_sock 、 udp_sock</span></span><br><span class="line"><span class="comment">	 * tcp_sock		tcp_prot	sizeof(tcp_sock) 约2264字节</span></span><br><span class="line"><span class="comment">	 * udp_sock		udp_prot  	sizeof(udp_sock) 约1152字节 */</span></span><br><span class="line">	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* icmp_prot 、 raw_prot 才有标志里才有这个 */</span></span><br><span class="line">	<span class="keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)</span><br><span class="line">		sk-&gt;sk_reuse = SK_CAN_REUSE;</span><br><span class="line"></span><br><span class="line">	inet = inet_sk(sk);</span><br><span class="line">	inet_assign_bit(IS_ICSK, sk, INET_PROTOSW_ICSK &amp; answer_flags);</span><br><span class="line"></span><br><span class="line">	inet_clear_bit(NODEFRAG, sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;</span><br><span class="line">		inet-&gt;inet_num = protocol;</span><br><span class="line">		<span class="keyword">if</span> (IPPROTO_RAW == protocol)</span><br><span class="line">			inet_set_bit(HDRINCL, sk);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(net-&gt;ipv4.sysctl_ip_no_pmtu_disc))</span><br><span class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_DONT;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_WANT;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;inet-&gt;inet_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	sock_init_data(sock, sk);</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_destruct	   = inet_sock_destruct;</span><br><span class="line">	sk-&gt;sk_protocol	   = protocol;</span><br><span class="line">	sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;</span><br><span class="line">	sk-&gt;sk_txrehash = READ_ONCE(net-&gt;core.sysctl_txrehash);</span><br><span class="line"></span><br><span class="line">	inet-&gt;uc_ttl	= <span class="number">-1</span>;</span><br><span class="line">	inet_set_bit(MC_LOOP, sk);</span><br><span class="line">	inet-&gt;mc_ttl	= <span class="number">1</span>;</span><br><span class="line">	inet_set_bit(MC_ALL, sk);</span><br><span class="line">	inet-&gt;mc_index	= <span class="number">0</span>;</span><br><span class="line">	inet-&gt;mc_list	= <span class="literal">NULL</span>;</span><br><span class="line">	inet-&gt;rcv_tos	= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SOCK_RAW 才会走进这里，因为前面只有 SOCK_RAW 才给 inet_num 赋值了啊 */</span></span><br><span class="line">	<span class="keyword">if</span> (inet-&gt;inet_num) &#123;</span><br><span class="line">		<span class="comment">/* It assumes that any protocol which allows</span></span><br><span class="line"><span class="comment">		 * the user to assign a number at socket</span></span><br><span class="line"><span class="comment">		 * creation time automatically shares.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Add to protocol hash chains.</span></span><br><span class="line"><span class="comment">		 * raw_hash_sk */</span></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			sk_common_release(sk);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tcp_v4_init_sock 、 udp_init_sock </span></span><br><span class="line"><span class="comment">	 * 负责对应套接字初始化相关 */</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;init(sk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			sk_common_release(sk);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用户态socket()调过来，kern是0, 可以看 sock_create </span></span><br><span class="line"><span class="comment">	 * 如果是内核创建套接字，kern是1，就不再走bpf相关钩子了 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kern) &#123;</span><br><span class="line">		err = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			sk_common_release(sk);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">out_rcu_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>tcp_v4_init_sock是对tcp_sock的成员做初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span> A lot of things set to zero explicitly by call to</span></span><br><span class="line"><span class="comment"> *       sk_alloc() so need not be done here.</span></span><br><span class="line"><span class="comment"> * 由 inet_create 调用</span></span><br><span class="line"><span class="comment"> * 这是tcp socket初始化必经之路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_v4_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">	tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">	icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">	tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Address-family independent initialization for a tcp_sock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> A lot of things set to zero explicitly by call to</span></span><br><span class="line"><span class="comment"> *       sk_alloc() so need not be done here.</span></span><br><span class="line"><span class="comment"> * 由 tcp_v4_init_sock 、 tcp_v6_init_sock 调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tcp_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	tp-&gt;out_of_order_queue = RB_ROOT;</span><br><span class="line">	sk-&gt;tcp_rtx_queue = RB_ROOT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化定时器相关 */</span></span><br><span class="line">	tcp_init_xmit_timers(sk);</span><br><span class="line">	</span><br><span class="line">	INIT_LIST_HEAD(&amp;tp-&gt;tsq_node);</span><br><span class="line">	INIT_LIST_HEAD(&amp;tp-&gt;tsorted_sent_queue);</span><br><span class="line"></span><br><span class="line">	icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;</span><br><span class="line">	icsk-&gt;icsk_rto_min = TCP_RTO_MIN;</span><br><span class="line">	icsk-&gt;icsk_delack_max = TCP_DELACK_MAX;</span><br><span class="line">	tp-&gt;mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);</span><br><span class="line">	minmax_reset(&amp;tp-&gt;rtt_min, tcp_jiffies32, ~<span class="number">0U</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* So many TCP implementations out there (incorrectly) count the</span></span><br><span class="line"><span class="comment">	 * initial SYN frame in their delayed-ACK and congestion control</span></span><br><span class="line"><span class="comment">	 * algorithms that we must have the following bandaid to talk</span></span><br><span class="line"><span class="comment">	 * efficiently to them.  -DaveM</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcp_snd_cwnd_set(tp, TCP_INIT_CWND);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There&#x27;s a bubble in the pipe until at least the first ACK. */</span></span><br><span class="line">	tp-&gt;app_limited = ~<span class="number">0U</span>;</span><br><span class="line">	tp-&gt;rate_app_limited = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See draft-stevens-tcpca-spec-01 for discussion of the</span></span><br><span class="line"><span class="comment">	 * initialization of these values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tp-&gt;snd_ssthresh = TCP_INFINITE_SSTHRESH;</span><br><span class="line">	tp-&gt;snd_cwnd_clamp = ~<span class="number">0</span>;</span><br><span class="line">	tp-&gt;mss_cache = TCP_MSS_DEFAULT;</span><br><span class="line"></span><br><span class="line">	tp-&gt;reordering = READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_reordering);</span><br><span class="line">	tcp_assign_congestion_control(sk);</span><br><span class="line"></span><br><span class="line">	tp-&gt;tsoffset = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.reo_wnd_steps = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_write_space = sk_stream_write_space;</span><br><span class="line">	sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);</span><br><span class="line"></span><br><span class="line">	icsk-&gt;icsk_sync_mss = tcp_sync_mss;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 默认 tcp_sock 发送缓冲区大小:16384(16K) 	接收缓冲区大小:131072(128K)</span></span><br><span class="line"><span class="comment">	 * net.ipv4.tcp_wmem = 4096        16384   4194304 </span></span><br><span class="line"><span class="comment">	 * net.ipv4.tcp_rmem = 4096        131072  6291456 */</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_sndbuf, READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_wmem[<span class="number">1</span>]));</span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_rcvbuf, READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_rmem[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化用于调整TCP接收窗口大小的缩放比例因子 */</span></span><br><span class="line">	tcp_scaling_ratio_init(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 表示该sk支持零拷贝操作，通常用于优化网络数据传输</span></span><br><span class="line"><span class="comment">	 * 减少数据在内核和用户空间之间的拷贝次数 */</span></span><br><span class="line">	set_bit(SOCK_SUPPORT_ZC, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 增加 tcp_sock 的引用计数，确保其在使用期间不会被释放</span></span><br><span class="line"><span class="comment">	 * 在 tcp_v4_destroy_sock 中关闭tcp_sock时，会减引用计数 */</span></span><br><span class="line">	sk_sockets_allocated_inc(sk);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_init_sock);</span><br></pre></td></tr></table></figure>

<hr>
<p>我们已经申请好了socket结构，而socket结构对于用户态是无感的，用户态是通过文件描述符fd来管理对应的socket结构的。因此就需要将socket映射出一个与之对应的文件描述符fd，返回给上层应用，sock_map_fd就是做这件事情的。它首先通过get_unused_fd_flags获取当前进程的最小的未使用的文件描述符fd，然后调用sock_alloc_file创建一个文件对象，再通过fd_install，完成fd 和 文件对象的关联。而文件对象也是跟socket相互关联的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 __sys_socket 调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sock_map_fd</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取当前进程的一个未使用的文件描述符fd */</span></span><br><span class="line">	fd = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(fd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		sock_release(sock);</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建一个文件对象，将 socket 和 file 关联起来 */</span></span><br><span class="line">	newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(newfile)) &#123;</span><br><span class="line">		<span class="comment">/* 关联 fd 和 file，这样找到了 file，也就找到了 socket */</span></span><br><span class="line">		fd_install(fd, newfile);</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 有错误，将fd标记为未使用 */</span></span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(newfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>get_unused_fd_flags就是通过current(进程pcb结构)，拿到其中的files，这个files就是来管理这个进程所有的文件描述符的结构。files内部有一个fdt，fdt内部有一个二维指针fd，这个二维指针指向了fd array。用户态的fd其实就是这个fd array的数组索引。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 sock_map_fd 调用 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_unused_fd_flags</span><span class="params">(<span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __get_unused_fd_flags(flags, rlimit(RLIMIT_NOFILE));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_unused_fd_flags);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __get_unused_fd_flags(<span class="type">unsigned</span> flags, <span class="type">unsigned</span> <span class="type">long</span> nofile)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc_fd(<span class="number">0</span>, nofile, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allocate a file descriptor, mark it busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_fd</span><span class="params">(<span class="type">unsigned</span> start, <span class="type">unsigned</span> end, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">repeat:</span><br><span class="line">	fdt = files_fdtable(files);</span><br><span class="line">	fd = start;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; files-&gt;next_fd)</span><br><span class="line">		fd = files-&gt;next_fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; fdt-&gt;max_fds)</span><br><span class="line">		fd = find_next_fd(fdt, fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * N.B. For clone tasks sharing a files structure, this test</span></span><br><span class="line"><span class="comment">	 * will limit the total number of files that can be opened.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = -EMFILE;</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= end)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	error = expand_files(files, fd);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we needed to expand the fs array we</span></span><br><span class="line"><span class="comment">	 * might have blocked - try again.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start &lt;= files-&gt;next_fd)</span><br><span class="line">		files-&gt;next_fd = fd + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__set_open_fd(fd, fdt);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; O_CLOEXEC)</span><br><span class="line">		__set_close_on_exec(fd, fdt);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__clear_close_on_exec(fd, fdt);</span><br><span class="line">	error = fd;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">/* Sanity check */</span></span><br><span class="line">	<span class="keyword">if</span> (rcu_access_pointer(fdt-&gt;fd[fd]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;alloc_fd: slot %d not NULL!\n&quot;</span>, fd);</span><br><span class="line">		rcu_assign_pointer(fdt-&gt;fd[fd], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open file table structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">bool</span> resize_in_progress;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> resize_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所有的文件描述符都在fdt的fd数组里存着 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> next_fd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *open_fds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *full_fds_bits;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>sock_alloc_file会申请一个file对象，并且它将与socket互相指向对方，这就意味着找到其中一个，就可以找到另外一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">sock_alloc_file</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dname)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dname)</span><br><span class="line">		dname = sock-&gt;sk ? sock-&gt;sk-&gt;sk_prot_creator-&gt;name : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alloc 一个file 绑定了 socket_file_ops 回调函数集合，sock_mnt为一个挂载点 */</span></span><br><span class="line">	file = alloc_file_pseudo(SOCK_INODE(sock), sock_mnt, dname,</span><br><span class="line">				O_RDWR | (flags &amp; O_NONBLOCK),</span><br><span class="line">				&amp;socket_file_ops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		sock_release(sock);</span><br><span class="line">		<span class="keyword">return</span> file;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file-&gt;f_mode |= FMODE_NOWAIT;</span><br><span class="line">	<span class="comment">/* socket、file 互相指向对方 */</span></span><br><span class="line">	sock-&gt;file = file;</span><br><span class="line">	file-&gt;private_data = sock;</span><br><span class="line">	<span class="comment">/* 标记为流式文件，不支持lseek(随机访问)？*/</span></span><br><span class="line">	stream_open(SOCK_INODE(sock), file);</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>fd_install就是将申请的file对象，按照获取到的fd，将file放到fdt的fd数组的fd索引位置处。这样后续用户态传入fd，就可以在这个fdt的fd数组中索引到file，而通过file就可以找到与之关联的socket结构。从而内核可以再对socket结构去做对应的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由 sock_map_fd 、 __sys_accept4_file 调用</span></span><br><span class="line"><span class="comment"> * 目标就是把 file 放进 fdt-&gt;fd 里面，完成 fd 与 file 的关联</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fd_install</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_sched();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(files-&gt;resize_in_progress)) &#123;</span><br><span class="line">		rcu_read_unlock_sched();</span><br><span class="line">		spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">		fdt = files_fdtable(files);</span><br><span class="line">		BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">		rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">		spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* coupled with smp_wmb() in expand_fdtable() */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	fdt = rcu_dereference_sched(files-&gt;fdt);</span><br><span class="line">	<span class="comment">/* 正常应该为这个里面应该为空，如果不为空，触发BUG */</span></span><br><span class="line">	BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 将file放进fd二维指针指向的数组的fd位置，完成 fd 与 file 的关联 */</span></span><br><span class="line">	rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">	rcu_read_unlock_sched();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>socket函数就是在内核中创建了一个socket_alloc结构，并且会根据传入的type、protocol来创建对应的sock结构。之后再创建一个文件对象，使之与socket相互关联。再选出一个最小未使用的fd，将文件对象存储到文件描述符列表fd位置处，将fd返给用户态。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/socket/" rel="tag"># socket</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/09/syscall%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" rel="prev" title="syscall调用流程分析">
                  <i class="fa fa-angle-left"></i> syscall调用流程分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/12/16/bind%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="next" title="bind系统调用">
                  bind系统调用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2025 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wangzhixin</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
