<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"base16/onedark","dark":"base16/onedark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true,"highlight":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="发送完第一次握手包(syn)后，被动打开方，是如何处理syn包的呢？主要介绍下这块。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP三次握手-接收syn（一）">
<meta property="og:url" content="http://example.com/2025/12/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6syn%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="积硅步，至千里">
<meta property="og:description" content="发送完第一次握手包(syn)后，被动打开方，是如何处理syn包的呢？主要介绍下这块。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-25T14:04:38.000Z">
<meta property="article:modified_time" content="2026-01-05T14:36:34.204Z">
<meta property="article:author" content="wangzhixin">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="tcp建连">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/12/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6syn%EF%BC%88%E4%B8%80%EF%BC%89/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/12/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6syn%EF%BC%88%E4%B8%80%EF%BC%89/","path":"2025/12/25/TCP三次握手-接收syn（一）/","title":"TCP三次握手-接收syn（一）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TCP三次握手-接收syn（一） | 积硅步，至千里</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">积硅步，至千里</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzhixin</p>
  <div class="site-description" itemprop="description">Linux C/C++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/25/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6syn%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhixin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积硅步，至千里">
      <meta itemprop="description" content="Linux C/C++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TCP三次握手-接收syn（一） | 积硅步，至千里">
      <meta itemprop="description" content="发送完第一次握手包(syn)后，被动打开方，是如何处理syn包的呢？主要介绍下这块。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP三次握手-接收syn（一）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-25 22:04:38" itemprop="dateCreated datePublished" datetime="2025-12-25T22:04:38+08:00">2025-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-05 22:36:34" itemprop="dateModified" datetime="2026-01-05T22:36:34+08:00">2026-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux6-6%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">linux6.6内核</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">发送完第一次握手包(syn)后，被动打开方，是如何处理syn包的呢？主要介绍下这块。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>数据包达到网卡，以及触发硬中断、软中断接收数据包，然后送往内核网络协议栈部分，我们暂时省略，后续再介绍。我们直接从 <strong>tcp_v4_rcv</strong> 开始看，这是tcp数据包从网络层到传输层的入口点。</p>
<p>syn包达到服务端后，通过 <strong>tcp_v4_rcv</strong> 送到了传输层tcp处理入口。首先会从 <strong>skb-&gt;pkt_type</strong> 中判断，这个数据包是不是发往本机的(<strong>PACKET_HOST</strong>)，如果不是发往本机的，直接跳转到 <strong>discard_it</strong>，将数据包释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  tcp_protocol，</span></span><br><span class="line"><span class="comment"> *  由 ip_protocol_deliver_rcu 调用</span></span><br><span class="line"><span class="comment"> *  这是tcp数据包从网络层到传输层的入口点</span></span><br><span class="line"><span class="comment"> *	From tcp_input.c </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 先拿到skb的所属网络设备的所属网络命名空间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">skb_drop_reason</span> <span class="title">drop_reason</span>;</span></span><br><span class="line">	<span class="type">int</span> sdif = inet_sdif(skb);</span><br><span class="line">	<span class="type">int</span> dif = inet_iif(skb);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	<span class="comment">/* 该值为true时，代表找到的sk是ehash里面的，在 __inet_lookup_established 中有加引用计数</span></span><br><span class="line"><span class="comment">	 * 所以搞个标志，便于后面不用的时候要减掉引用计数 */</span></span><br><span class="line">	<span class="type">bool</span> refcounted;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;</span><br><span class="line">	<span class="comment">/* 不是发给本机的包，直接丢弃，比如 网卡处于混杂模式*/</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">discard_it:</span><br><span class="line">	SKB_DR_OR(drop_reason, NOT_SPECIFIED);</span><br><span class="line">	<span class="comment">/* Discard frame. */</span></span><br><span class="line">	kfree_skb_reason(skb, drop_reason);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>无论包是否合法，只要是发给tcp的，并且是发给本机的包，都增加计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Count it even if it&#x27;s bad ，</span></span><br><span class="line"><span class="comment">	 * 无论包是否合法，只要是发给tcp的，并且是发给本机的包，都增加计数，</span></span><br><span class="line"><span class="comment">	 * 该计数可以在 netstat -st | grep segments 看到 */</span></span><br><span class="line">	__TCP_INC_STATS(net, TCP_MIB_INSEGS);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>然后调用 <strong>pskb_may_pull</strong> 确保 skb的线性部分必须至少包含tcp报文头，防止其在非线性部分，因为我们需要tcp头中的数据来做一些基本判断。因为ip层已经确保过ip头了，并且在 <strong>ip_local_deliver_finish</strong> 中，已经将data拉过ip头了，所以这里仅需要pull tcphdr大小即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  确保 skb 中线性部分至少包含完整 TCP 报文头，确保完整性，防止 tcp头 在非线性部分</span></span><br><span class="line"><span class="comment">	 *  这里为什么只确保了tcphdr？</span></span><br><span class="line"><span class="comment">	 *  原因是 数据包已经从网络层到达传输层，在交付过来时，已经对skb做过处理</span></span><br><span class="line"><span class="comment">	 *  可查看 ip_local_deliver_finish ，调用了 __skb_pull */</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr)))</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>此时的skb的data一定指向的就是tcp头，但是我感觉直接用 tcp_hdr更好点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 正是因为传递过来之前已经__skb_pull了，所以skb-&gt;data指向的就已经是tcp头这块了 </span></span><br><span class="line"><span class="comment">	 * 但是其实最好还是调用 tcp_hdr 会更安全 */</span></span><br><span class="line">	th = (<span class="type">const</span> <span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>判断下tcp头部的doff，注意它占四位，最多表示15，但是它的单位是4字节，也就是最多60字节，tcp选项最多也就是60-固定长度(20)&#x3D;40字节。如果doff小于5，那铁定包有问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 坏包 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(th-&gt;doff &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) / <span class="number">4</span>)) &#123;</span><br><span class="line">		drop_reason = SKB_DROP_REASON_PKT_TOO_SMALL;</span><br><span class="line">		<span class="keyword">goto</span> bad_packet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>可能有tcp选项，但是刚才我们只确保了线性部分至少包含tcphdr(20字节)，现在我们由doff，我们就再次确保整个tcp固定头部+选项头部全部在线性部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 可能有tcp选项，再pull下，确保skb线性部分至少包含tcp固定头部加tcp选项部分 */</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, th-&gt;doff * <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>初始化并验证 TCP 校验和的计算条件，如果校验和明显不可能正确（或无法计算），直接判定为校验错误，丢包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>因为前面为了确保tcp选项也在线性部分，调用该pskb_may_pull了，当长度不够时，它会重新申请内存挪过去，所以还得再次更新下tcp头部指针，防止其指向的是已失效的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pskb_may_pull了，所以再次更新下tcp头指针 */</span></span><br><span class="line">	th = (<span class="type">const</span> <span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>进入关键逻辑，来了一个发送本机的包，并且基本信息没明显问题，那就应该要寻找这个skb到底是属于哪个sk了，这决定哪个sk来接收这个skb啊。是调用__inet_lookup_skb来查找的，传入的 <strong>net-&gt;ipv4.tcp_death_row.hashinfo</strong>，很明显，这里面是该skb所属 网络命名空间 中来管理tcp各种哈希表集合的结构，such as ehash 、 bhash 、 bhash2 、 lhash2。它是在 <strong>tcp_set_hashinfo</strong> 中设置的, 如果是初始网络命名空间(init_net)，它指向 全局变量 <strong>tcp_hashinfo</strong>， 如果不是初始网络命名空间，它指向 动态申请的 inet_hashinfo结构。如果没找到sk，那就要根据其校验和是否正确来做处理，如果校验和正确，那给对方回个rst。如果校验和不对，那就不回rst了，直接更新下计数，释放掉包即可。如果找到了sk，才继续走后面的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">lookup:</span><br><span class="line">	<span class="comment">/* 查找该数据包所属的sk</span></span><br><span class="line"><span class="comment">	 * 可能返回established sk，也可能是listen sk，也可能是NULL </span></span><br><span class="line"><span class="comment">	 * 对于服务端来说，第一次握手包找到的是listen sk，客户端的ack(三次握手包)后查找到的应该是established sk</span></span><br><span class="line"><span class="comment">	 * 返回NULL 代表没有TCP监听该端口，所以要给对端发reset包 */</span></span><br><span class="line">	sk = __inet_lookup_skb(net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">			       skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">			       th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">no_tcp_socket:</span><br><span class="line">	drop_reason = SKB_DROP_REASON_NO_SOCKET;</span><br><span class="line">	<span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb))</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">	tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">csum_error:</span><br><span class="line">		drop_reason = SKB_DROP_REASON_TCP_CSUM;</span><br><span class="line">		trace_tcp_bad_csum(skb);</span><br><span class="line">		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);</span><br><span class="line">bad_packet:</span><br><span class="line">		__TCP_INC_STATS(net, TCP_MIB_INERRS);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 校验和正确，没有找到所属的sk，回个reset包 */</span></span><br><span class="line">		tcp_v4_send_reset(<span class="literal">NULL</span>, skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> &#123;</span></span><br><span class="line">	<span class="comment">/* This is for sockets with full identity only.  Sockets here will</span></span><br><span class="line"><span class="comment">	 * always be without wildcards and will have the following invariant:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *          TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 存储 established 状态sk的哈希表</span></span><br><span class="line"><span class="comment">	 * key为 四元组 、 随机值 、 hash_mix</span></span><br><span class="line"><span class="comment">	 * 哈希函数为 inet_ehashfn  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span>	*<span class="title">ehash</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span>			*ehash_locks;</span><br><span class="line">	<span class="comment">/* ehash_mask 为 ehash 哈希桶数量减1 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ehash_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ehash_locks_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ok, let&#x27;s try this, I give up, we do need a local binding</span></span><br><span class="line"><span class="comment">	 * TCP hash as well as the others for fast bind/connect.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>		*<span class="title">bind_bucket_cachep</span>;</span></span><br><span class="line">	<span class="comment">/* This bind table is hashed by local port </span></span><br><span class="line"><span class="comment">	 * 存储 端口 相关sk的哈希表</span></span><br><span class="line"><span class="comment">	 * key为 本地端口 、 hash_mix</span></span><br><span class="line"><span class="comment">	 * 哈希函数为inet_bhashfn </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span>	*<span class="title">bhash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>		*<span class="title">bind2_bucket_cachep</span>;</span></span><br><span class="line">	<span class="comment">/* This bind table is hashed by local port and sk-&gt;sk_rcv_saddr (ipv4)</span></span><br><span class="line"><span class="comment">	 * or sk-&gt;sk_v6_rcv_saddr (ipv6). This 2nd bind table is used</span></span><br><span class="line"><span class="comment">	 * primarily for expediting bind conflict resolution.</span></span><br><span class="line"><span class="comment">	 * 存储 地址、端口 相关sk的哈希表2</span></span><br><span class="line"><span class="comment">	 * key为 本地地址、本地端口、hash_mix</span></span><br><span class="line"><span class="comment">	 * 哈希函数为 ipv4_portaddr_hash</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span>	*<span class="title">bhash2</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			bhash_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The 2nd listener table hashed by local port and address </span></span><br><span class="line"><span class="comment">	 * ehash_mask 为 ehash 哈希桶数量减1 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			lhash2_mask;</span><br><span class="line">	<span class="comment">/* 存储 listen 状态sk的哈希表2</span></span><br><span class="line"><span class="comment">	 * key为 本地地址、本地端口 、hash_mix </span></span><br><span class="line"><span class="comment">	 * 哈希函数为 ipv4_portaddr_hash </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span>	*<span class="title">lhash2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span>				pernet;</span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_death_row</span> &#123;</span></span><br><span class="line">	<span class="type">refcount_t</span>		tw_refcount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Padding to avoid false sharing, tw_refcount can be often written </span></span><br><span class="line"><span class="comment">	 * 在 tcp_set_hashinfo 中设置的, 如果是初始网络命名空间(init_net)，它指向 tcp_hashinfo </span></span><br><span class="line"><span class="comment">	 * 如果不是初始网络命名空间，它指向 动态申请的 inet_hashinfo */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> 	*<span class="title">hashinfo</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">	<span class="type">int</span>			sysctl_max_tw_buckets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<ol>
<li>先尝试查看是否早期解复用，找到过skb所属sk，如果解复用过，那就直接返回sk即可。解复用是在 <strong>ip_rcv_finish_core</strong>中做的。</li>
<li>没有解复用过，调用 <strong>__inet_lookup</strong> 去查找。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 tcp_v4_rcv 调用 </span></span><br><span class="line"><span class="comment"> * 查找skb所属的sk</span></span><br><span class="line"><span class="comment"> * 按照以下顺序查找：先看是否早期解复用过、established 查找、listener 查找 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup_skb</span>(<span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">					     <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>,</span></span><br><span class="line"><span class="class">					     <span class="title">int</span> <span class="title">doff</span>,</span></span><br><span class="line"><span class="class">					     <span class="title">const</span> __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">					     <span class="title">const</span> __<span class="title">be16</span> <span class="title">dport</span>,</span></span><br><span class="line"><span class="class">					     <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>,</span></span><br><span class="line"><span class="class">					     <span class="title">bool</span> *<span class="title">refcounted</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb_dst(skb)-&gt;dev);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 尝试查看是否早期解复用，找到过skb所属sk */</span></span><br><span class="line">	sk = inet_steal_sock(net, skb, doff, iph-&gt;saddr, sport, iph-&gt;daddr, dport,</span><br><span class="line">			     refcounted, inet_ehashfn);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sk))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (sk)</span><br><span class="line">		<span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 没有早期解复用过，去skb的所属网络设备的所属网络命名空间的哈希表里查下 */</span></span><br><span class="line">	<span class="keyword">return</span> __inet_lookup(net, hashinfo, skb,</span><br><span class="line">			     doff, iph-&gt;saddr, sport,</span><br><span class="line">			     iph-&gt;daddr, dport, inet_iif(skb), sdif,</span><br><span class="line">			     refcounted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>可以看到，解复用就是判断了下tcp头部是否合法，合法则去 tcp哈希表集合中的 ehash哈希表中查找是否能找到匹配的sk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 ip_rcv_finish_core 调用 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_early_demux</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, skb_transport_offset(skb) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	th = tcp_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;doff &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) / <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sk = __inet_lookup_established(net, net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">				       iph-&gt;saddr, th-&gt;source,</span><br><span class="line">				       iph-&gt;daddr, ntohs(th-&gt;dest),</span><br><span class="line">				       skb-&gt;skb_iif, inet_sdif(skb));</span><br><span class="line">	<span class="keyword">if</span> (sk) &#123;</span><br><span class="line">		skb-&gt;sk = sk;</span><br><span class="line">		skb-&gt;destructor = sock_edemux;</span><br><span class="line">		<span class="keyword">if</span> (sk_fullsock(sk)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> =</span> rcu_dereference(sk-&gt;sk_rx_dst);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dst)</span><br><span class="line">				dst = dst_check(dst, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (dst &amp;&amp;</span><br><span class="line">			    sk-&gt;sk_rx_dst_ifindex == skb-&gt;skb_iif)</span><br><span class="line">				skb_dst_set_noref(skb, dst);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>在**__inet_lookup**中，也是先去 ehash 中查找，如果有匹配的sk，就直接返回。如果没有匹配的sk，代表跟发这个包的客户端还没有建立连接，那就去 lhash2 中找下，如果找到了，那当前肯定就处于建连过程，直接返回该 listen sk。如果没找到，就代表没有sk监听这个端口，那这个包就没有所属的sk，那就返回空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 __inet_lookup_skb 、 inet_lookup 调用 </span></span><br><span class="line"><span class="comment"> * 查找skb所属sk，先从established里找，找不到再从listener里面找 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">					 <span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">					 <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">int</span> <span class="title">doff</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> __<span class="title">be32</span> <span class="title">saddr</span>, <span class="title">const</span> __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> __<span class="title">be32</span> <span class="title">daddr</span>, <span class="title">const</span> __<span class="title">be16</span> <span class="title">dport</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> <span class="title">int</span> <span class="title">dif</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">bool</span> *<span class="title">refcounted</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u16 hnum = ntohs(dport);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先去 hashinfo 的 ehash 哈希表里面查下 */</span></span><br><span class="line">	sk = __inet_lookup_established(net, hashinfo, saddr, sport,</span><br><span class="line">				       daddr, hnum, dif, sdif);</span><br><span class="line">	*refcounted = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (sk)</span><br><span class="line">		<span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">	*refcounted = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/* 再去 hashinfo 的 lhash2 哈希表里面查下 */</span></span><br><span class="line">	<span class="keyword">return</span> __inet_lookup_listener(net, hashinfo, skb, doff, saddr,</span><br><span class="line">				      sport, daddr, hnum, dif, sdif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>计算ehash上的hash值，拿到对应哈希桶，遍历所有entry。如果ip port 收发网口均匹配，那就增加引用计数。再次判断是否匹配，因为加引用计数时，socket信息可能被并发修改了。还匹配，那就是找到了已连接的sk，返回它。反之，再次去查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 __inet_lookup 、 tcp_v4_early_demux 调用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup_established</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">				  <span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">const</span> __<span class="title">be32</span> <span class="title">saddr</span>, <span class="title">const</span> __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">const</span> __<span class="title">be32</span> <span class="title">daddr</span>, <span class="title">const</span> <span class="title">u16</span> <span class="title">hnum</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">const</span> <span class="title">int</span> <span class="title">dif</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	INET_ADDR_COOKIE(acookie, saddr, daddr);</span><br><span class="line">	<span class="type">const</span> __portpair ports = INET_COMBINED_PORTS(sport, hnum);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">/* Optimize here for direct hit, only listening connections can</span></span><br><span class="line"><span class="comment">	 * have wildcards anyways.</span></span><br><span class="line"><span class="comment">	 * 计算哈希，并拿到所在ehash的哈希桶</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hash = inet_ehashfn(net, daddr, hnum, saddr, sport);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> slot = hash &amp; hashinfo-&gt;ehash_mask;</span><br><span class="line">	<span class="comment">/* 拿到具体的哈希桶 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span> *<span class="title">head</span> =</span> &amp;hashinfo-&gt;ehash[slot];</span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">	<span class="comment">/* 遍历所属的哈希桶上的所有entry */</span></span><br><span class="line">	sk_nulls_for_each_rcu(sk, node, &amp;head-&gt;chain) &#123;</span><br><span class="line">		<span class="comment">/* hash不相等，那只是哈希冲突了，落在一个桶上，此sk不是我们的目标 */</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_hash != hash)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 比较ip port 收发网口是否完全匹配 */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(inet_match(net, sk, acookie, ports, dif, sdif))) &#123;</span><br><span class="line">			<span class="comment">/* 如果找到了匹配的sk ，但是它正在销毁，那就返回空 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!refcount_inc_not_zero(&amp;sk-&gt;sk_refcnt)))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 再次检查是否匹配，因为加引用过程，可能socket的信息又被并发改了 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!inet_match(net, sk, acookie,</span><br><span class="line">						 ports, dif, sdif))) &#123;</span><br><span class="line">				sock_gen_put(sk);</span><br><span class="line">				<span class="keyword">goto</span> begin;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> found;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if the nulls value we got at the end of this lookup is</span></span><br><span class="line"><span class="comment">	 * not the expected one, we must restart lookup.</span></span><br><span class="line"><span class="comment">	 * We probably met an item that was moved to another chain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (get_nulls_value(node) != slot)</span><br><span class="line">		<span class="keyword">goto</span> begin;</span><br><span class="line">out:</span><br><span class="line">	sk = <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line">	<span class="keyword">return</span> sk;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__inet_lookup_established);</span><br></pre></td></tr></table></figure>

<hr>
<p>如果 ehash 中没找到匹配的sk，那就在 lhash2 上找，首先是 daddr 和 hnum 去找，如果没有，则尝试 INADDR_ANY hnum 去找，因为有可能绑定的地址就是 INADDR_ANY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由 __inet_lookup 、 inet_lookup_listener 、 tcp_v4_send_reset 调用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup_listener</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">				    <span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">				    <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">int</span> <span class="title">doff</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> __<span class="title">be32</span> <span class="title">saddr</span>, __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> __<span class="title">be32</span> <span class="title">daddr</span>, <span class="title">const</span> <span class="title">unsigned</span> <span class="title">short</span> <span class="title">hnum</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> <span class="title">int</span> <span class="title">dif</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* lhash2上的哈希桶 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> *<span class="title">ilb2</span>;</span></span><br><span class="line">	<span class="comment">/* 存储查找到的sk */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* 存储daddr和hnum计算的hash值 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hash2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lookup redirect from BPF */</span></span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;bpf_sk_lookup_enabled) &amp;&amp;</span><br><span class="line">	    hashinfo == net-&gt;ipv4.tcp_death_row.hashinfo) &#123;</span><br><span class="line">		result = inet_lookup_run_sk_lookup(net, IPPROTO_TCP, skb, doff,</span><br><span class="line">						   saddr, sport, daddr, hnum, dif,</span><br><span class="line">						   inet_ehashfn);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据daddr、hnum 计算lhash2表上的hash值 */</span></span><br><span class="line">	hash2 = ipv4_portaddr_hash(net, daddr, hnum);</span><br><span class="line">	<span class="comment">/* 根据hash2，拿到lhash2上对应的哈希桶 */</span></span><br><span class="line">	ilb2 = inet_lhash2_bucket(hashinfo, hash2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先根据 skb里面ip头中的daddr 去找，如果找到了，直接返回 */</span></span><br><span class="line">	result = inet_lhash2_lookup(net, ilb2, skb, doff,</span><br><span class="line">				    saddr, sport, daddr, hnum,</span><br><span class="line">				    dif, sdif);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lookup lhash2 with INADDR_ANY </span></span><br><span class="line"><span class="comment">	 * 根据 INADDR_ANY 、hnum 计算lhash2表上的hash值 */</span></span><br><span class="line">	hash2 = ipv4_portaddr_hash(net, htonl(INADDR_ANY), hnum);</span><br><span class="line">	<span class="comment">/* 再次拿到 新hash2 对应的lhash2上的哈希桶 */</span></span><br><span class="line">	ilb2 = inet_lhash2_bucket(hashinfo, hash2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 再根据 INADDR_ANY 去找 */</span></span><br><span class="line">	result = inet_lhash2_lookup(net, ilb2, skb, doff,</span><br><span class="line">				    saddr, sport, htonl(INADDR_ANY), hnum,</span><br><span class="line">				    dif, sdif);</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(result))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__inet_lookup_listener);</span><br></pre></td></tr></table></figure>

<hr>
<p>经过上面的流程，我们又回到了 <strong>tcp_v4_rcv</strong> 中，此时已经找到了匹配的sk，则去判断 sk当前处于什么状态。针对首次建立连接，此时的sk大概率是从 lhash2 中找到的listen sk，此时应该处于 <strong>TCP_LISTEN</strong>。会调用 <strong>tcp_v4_do_rcv</strong>，处理完后，直接第一次握手包接收就结束了。因此我们要着重看  <strong>tcp_v4_do_rcv</strong> 的逻辑实现。我们放到下篇来介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 处于 TCP_LISTEN 状态的服务端收到发往该sk上的包后，走这里的处理逻辑</span></span><br><span class="line"><span class="comment">	 * 这个sk是在lhash2里面找到的</span></span><br><span class="line"><span class="comment">	 * 即第一次握手包是在这里接收的，第二次握手包是在这里面发送的 */</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">		<span class="comment">/* listen状态的，走这里 */</span></span><br><span class="line">		ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">		<span class="keyword">goto</span> put_and_return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">put_and_return:</span><br><span class="line">	<span class="keyword">if</span> (refcounted)</span><br><span class="line">		sock_put(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/socket/" rel="tag"># socket</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
              <a href="/tags/tcp%E5%BB%BA%E8%BF%9E/" rel="tag"># tcp建连</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/23/connect%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="connect系统调用（二）">
                  <i class="fa fa-angle-left"></i> connect系统调用（二）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/12/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6syn%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="next" title="TCP三次握手-接收syn（二）">
                  TCP三次握手-接收syn（二） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2025 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wangzhixin</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
