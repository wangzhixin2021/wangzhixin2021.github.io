<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"base16/onedark","dark":"base16/onedark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true,"highlight":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="我们经常使用LD_PRELOAD，但是有时候会发现preload不生效(比如:elf文件中的全局函数，编写同名函数，无法hook该函数)，那么LD_PRELOAD的原理是什么呢？以及有没有其它方式实现hook效果呢？。">
<meta property="og:type" content="article">
<meta property="og:title" content="preload_and_poor_inline_hook">
<meta property="og:url" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/index.html">
<meta property="og:site_name" content="积硅步，至千里">
<meta property="og:description" content="我们经常使用LD_PRELOAD，但是有时候会发现preload不生效(比如:elf文件中的全局函数，编写同名函数，无法hook该函数)，那么LD_PRELOAD的原理是什么呢？以及有没有其它方式实现hook效果呢？。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128185814.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190004.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190117.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190328.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190920.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128215145.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128215437.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128231305.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190328.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128222639.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128223006.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225233.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225313.png">
<meta property="og:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225334.png">
<meta property="article:published_time" content="2026-01-28T15:48:41.000Z">
<meta property="article:modified_time" content="2026-01-31T08:09:28.744Z">
<meta property="article:author" content="wangzhixin">
<meta property="article:tag" content="LD_PRELOAD">
<meta property="article:tag" content="hook">
<meta property="article:tag" content="poor_inline_hook">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128185814.png">


<link rel="canonical" href="http://example.com/2026/01/28/preload_and_poor_inline_hook/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2026/01/28/preload_and_poor_inline_hook/","path":"2026/01/28/preload_and_poor_inline_hook/","title":"preload_and_poor_inline_hook"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>preload_and_poor_inline_hook | 积硅步，至千里</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">积硅步，至千里</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">一、背景介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">二、问题介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-LD-PRELOAD"><span class="nav-number">3.</span> <span class="nav-text">三、什么是 LD_PRELOAD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88elf%E9%87%8C%E7%9A%84%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%97%A0%E6%B3%95hook"><span class="nav-number">4.</span> <span class="nav-text">四、为什么elf里的普通函数无法hook</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-write-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD-hook-%E6%88%90%E5%8A%9F%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 write 为什么能 hook 成功？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-func-myelf-get-raid-status-%E4%B8%BA%E4%BB%80%E4%B9%88-hook-%E5%A4%B1%E8%B4%A5%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 func_myelf_get_raid_status 为什么 hook 失败？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8B"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 从汇编角度看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81my-poor-inline-hook"><span class="nav-number">5.</span> <span class="nav-text">五、my poor inline hook</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzhixin</p>
  <div class="site-description" itemprop="description">Linux C/C++</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/28/preload_and_poor_inline_hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhixin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积硅步，至千里">
      <meta itemprop="description" content="Linux C/C++">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="preload_and_poor_inline_hook | 积硅步，至千里">
      <meta itemprop="description" content="我们经常使用LD_PRELOAD，但是有时候会发现preload不生效(比如:elf文件中的全局函数，编写同名函数，无法hook该函数)，那么LD_PRELOAD的原理是什么呢？以及有没有其它方式实现hook效果呢？。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          preload_and_poor_inline_hook
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-28 23:48:41" itemprop="dateCreated datePublished" datetime="2026-01-28T23:48:41+08:00">2026-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-31 16:09:28" itemprop="dateModified" datetime="2026-01-31T16:09:28+08:00">2026-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux6-6%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">linux6.6内核</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">我们经常使用LD_PRELOAD，但是有时候会发现preload不生效(比如:elf文件中的全局函数，编写同名函数，无法hook该函数)，那么LD_PRELOAD的原理是什么呢？以及有没有其它方式实现hook效果呢？。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>部门每年都有培训与分享的计划，这次在领导的要求下，让我组织一次内部分享。我选取了一个在<strong>自动化探针（硬件监测）项目</strong>中真实遇到的问题，作为本次分享主题，主要围绕 <strong>LD_PRELOAD 与 inline hook</strong> 介绍。</p>
<p>首先介绍下自动化探针，它的核心目标，是对服务器硬件与系统状态进行<strong>自动采集、分析与上报</strong>，包括：</p>
<ul>
<li>CPU &#x2F; 内存 &#x2F; 网络 &#x2F; 磁盘 &#x2F; RAID &#x2F; 风扇 &#x2F; 电源 等多类指标</li>
<li>数据采集 → 写入环形缓冲区 → 消费线程读取 → 格式化 → 上报平台</li>
</ul>
<h2 id="二、问题介绍"><a href="#二、问题介绍" class="headerlink" title="二、问题介绍"></a>二、问题介绍</h2><p>在自动化探针项目中，我们需要<strong>单元自测</strong>来验证指标采集逻辑是否正确。</p>
<p>有些指标很好构造，比如：</p>
<ul>
<li>僵尸进程数量</li>
<li>文件句柄数</li>
<li>CPU 使用率</li>
<li>内存占用<br>这些都可以通过写小程序、人为制造负载，很容易构造测试环境。</li>
</ul>
<p>有些指标几乎没法“真实构造”，比如：</p>
<ul>
<li>硬盘异常 </li>
<li>风扇转速过低</li>
<li>温度传感器异常</li>
</ul>
<p>在测试环境中，<strong>不可能为了测试去真的搞坏硬盘或风扇。</strong>  我们希望的是不更改源码、不重新编译、不修改默认的配置文件来模拟各种异常场景，所以我们使用了preload来做测试。</p>
<h2 id="三、什么是-LD-PRELOAD"><a href="#三、什么是-LD-PRELOAD" class="headerlink" title="三、什么是 LD_PRELOAD"></a>三、什么是 LD_PRELOAD</h2><p><code>LD_PRELOAD</code> 是 Linux 动态链接器（ld.so）提供的一个机制：允许在程序启动时，优先加载用户指定的共享库，并优先使用其中的符号实现。</p>
<p>比如下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了验证preload是否能hook 自身elf的函数，</span></span><br><span class="line"><span class="comment"> * 该函数返回raid卡状态是否正常 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_myelf_get_raid_status</span><span class="params">(<span class="type">bool</span> *exception)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is myelf get raid status func\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set exception to false */</span></span><br><span class="line">    *exception = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了验证preload是否能hook glibc的函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func_glibc_write_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> msg[] = <span class="string">&quot;This is glibc write&#x27;s data message.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;./testfile.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(fd, msg, <span class="built_in">strlen</span>(msg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File operations completed successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> exception;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s starting ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test func glibc write data\n&quot;</span>);</span><br><span class="line">    func_glibc_write_data();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test func myelf get raid status\n&quot;</span>);</span><br><span class="line">    func_myelf_get_raid_status(&amp;exception);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;raid status is %s\n&quot;</span>, exception ? <span class="string">&quot;abnormal&quot;</span> : <span class="string">&quot;normal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s ending ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序里，主要做了两件事：</p>
<ol>
<li>调用 <strong>func_glibc_write_data</strong> 来往当前目录下的testfile.txt文件中，写入消息”This is glibc write’s data message.\n”。</li>
<li>调用 <strong>func_myelf_get_raid_status</strong> 来获取raid卡状态。</li>
</ol>
<p>我们写了一个供preload用的so，主要用来 hook <strong>write</strong>，及 <strong>func_myelf_get_raid_status</strong> ，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== write hook ========== */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">ssize_t</span> <span class="params">(*<span class="type">fn_write_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">fn_write_t</span> g_real_write = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> msg[] = <span class="string">&quot;This is hook glibc write&#x27;s data message.\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> hook_msg[] = <span class="string">&quot;[hook write]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write) &#123;</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 避免递归：不要在这里 printf */</span></span><br><span class="line">    g_real_write(STDOUT_FILENO, hook_msg, <span class="keyword">sizeof</span>(hook_msg) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_real_write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== hook ELF 的函数 ========== */</span></span><br><span class="line"><span class="comment">/* 和 main 里函数签名必须完全一致，会发现该函数根本不能hook成功，因为要hook的那个函数是elf里的全局函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_myelf_get_raid_status</span><span class="params">(<span class="type">bool</span> *exception)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> hook_msg[] = <span class="string">&quot;[hook func_myelf_get_raid_status]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write) &#123;</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提示下 hook 成功了*/</span></span><br><span class="line">    g_real_write(STDOUT_FILENO, hook_msg, <span class="keyword">sizeof</span>(hook_msg) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模拟异常 */</span></span><br><span class="line">    *exception = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果hook成功，则预期会打印 <strong>[hook write]</strong> 、<strong>[hook func_myelf_get_raid_status]</strong>。<br>我们看下结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_PRELOAD=./preload.so ./main</span>                                            </span><br><span class="line">./main starting ...</span><br><span class="line">-------------------------</span><br><span class="line">test func glibc write data</span><br><span class="line">[hook write]</span><br><span class="line">File operations completed successfully.</span><br><span class="line">-------------------------</span><br><span class="line">test func myelf get raid status</span><br><span class="line">this is myelf get raid status func</span><br><span class="line">raid status is normal</span><br><span class="line">-------------------------</span><br><span class="line">./main ending ...</span><br></pre></td></tr></table></figure>

<p>从结果可以看出来：</p>
<ol>
<li>对 <strong>write</strong> 函数 hook 成功了，打印了 <strong>[hook write]</strong>。</li>
<li><strong>func_myelf_get_raid_status</strong> hook 失败了。这就是我在自动化探针中遇到的问题。想使用preload模拟异常，但是hook不生效。</li>
</ol>
<p>这两个函数的区别在于：一个是glibc中的函数、一个是elf里的普通函数。</p>
<h2 id="四、为什么elf里的普通函数无法hook"><a href="#四、为什么elf里的普通函数无法hook" class="headerlink" title="四、为什么elf里的普通函数无法hook"></a>四、为什么elf里的普通函数无法hook</h2><h3 id="4-1-write-为什么能-hook-成功？"><a href="#4-1-write-为什么能-hook-成功？" class="headerlink" title="4.1 write 为什么能 hook 成功？"></a>4.1 write 为什么能 hook 成功？</h3><p>因为 write 是：</p>
<ol>
<li>glibc 提供的外部符号  </li>
<li>调用时通过 PLT&#x2F;GOT  </li>
<li>在运行时由动态链接器(ld.so)解析</li>
</ol>
<p>而 <code>LD_PRELOAD</code> 正是插在<strong>动态符号解析阶段</strong>，优先提供符号实现。<br>所以：<br><code>write → PLT → GOT → 动态链接器 → preload.so</code></p>
<p>动态链接器优先选中了我们 preload 里的 write。</p>
<h3 id="4-2-func-myelf-get-raid-status-为什么-hook-失败？"><a href="#4-2-func-myelf-get-raid-status-为什么-hook-失败？" class="headerlink" title="4.2 func_myelf_get_raid_status 为什么 hook 失败？"></a>4.2 func_myelf_get_raid_status 为什么 hook 失败？</h3><p>因为它是：</p>
<ol>
<li>主程序 ELF 自己定义的普通函数  </li>
<li>链接时地址已经确定  </li>
<li>调用时往往是直接 <code>call 固定地址</code>  </li>
<li>不经过 GOT&#x2F;PLT  </li>
<li>不经过动态符号解析</li>
</ol>
<p>所以：</p>
<ol>
<li>动态链接器根本“插不上手” </li>
<li>LD_PRELOAD 对这种函数天然无效</li>
</ol>
<h3 id="4-3-从汇编角度看"><a href="#4-3-从汇编角度看" class="headerlink" title="4.3 从汇编角度看"></a>4.3 从汇编角度看</h3><p>我们可以从汇编代码查看到调用普通函数及调用glibc函数的区别，就会更加理解上面的说的结论。</p>
<p>我们看下 <code>main</code> 、<code>func_glibc_write_data</code> 、<code>func_myelf_get_raid_status</code>函数的汇编代码，可以看到elf里写的普通函数，如 <code>func_glibc_write_data</code> 、<code>func_myelf_get_raid_status</code>，都是直接调用的，call的都是具体的函数的地址。但是 glibc中的函数，比如 <code>write</code>，调用的是plt表中函数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000555555555295 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000555555555296 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x0000555555555299 &lt;+4&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x000055555555529d &lt;+8&gt;:     mov    %edi,-0x14(%rbp)</span><br><span class="line">   0x00005555555552a0 &lt;+11&gt;:    mov    %rsi,-0x20(%rbp)</span><br><span class="line">=&gt; 0x00005555555552a4 &lt;+15&gt;:    mov    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555552a8 &lt;+19&gt;:    mov    (%rax),%rax</span><br><span class="line">   0x00005555555552ab &lt;+22&gt;:    mov    %rax,%rsi</span><br><span class="line">   0x00005555555552ae &lt;+25&gt;:    lea    0xdbb(%rip),%rax        # 0x555555556070</span><br><span class="line">   0x00005555555552b5 &lt;+32&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00005555555552b8 &lt;+35&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00005555555552bd &lt;+40&gt;:    call   0x555555555050 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555552c2 &lt;+45&gt;:    lea    0xdb8(%rip),%rax        # 0x555555556081</span><br><span class="line">   0x00005555555552c9 &lt;+52&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00005555555552cc &lt;+55&gt;:    call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555552d1 &lt;+60&gt;:    lea    0xdc3(%rip),%rax        # 0x55555555609b</span><br><span class="line">   0x00005555555552d8 &lt;+67&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00005555555552db &lt;+70&gt;:    call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555552e0 &lt;+75&gt;:    call   0x5555555551be &lt;func_glibc_write_data&gt;</span><br><span class="line">   0x00005555555552e5 &lt;+80&gt;:    lea    0xd95(%rip),%rax        # 0x555555556081</span><br><span class="line">   0x00005555555552ec &lt;+87&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00005555555552ef &lt;+90&gt;:    call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555552f4 &lt;+95&gt;:    lea    0xdbd(%rip),%rax        # 0x5555555560b8</span><br><span class="line">   0x00005555555552fb &lt;+102&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x00005555555552fe &lt;+105&gt;:   call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x0000555555555303 &lt;+110&gt;:   lea    -0x1(%rbp),%rax</span><br><span class="line">   0x0000555555555307 &lt;+114&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555530a &lt;+117&gt;:   call   0x555555555199 &lt;func_myelf_get_raid_status&gt;</span><br><span class="line">   0x000055555555530f &lt;+122&gt;:   movzbl -0x1(%rbp),%eax</span><br><span class="line">   0x0000555555555313 &lt;+126&gt;:   test   %al,%al</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>func_myelf_get_raid_status</code> 的代码段其实地址就是 <code>0x555555555199</code>，与main函数中的call地址符合。这也就是我们刚才4.2中说的，调用 <code>func_myelf_get_raid_status</code> ，不经过动态符号解析，不经过 GOT&#x2F;PLT ，动态链接器根本“插不上手” 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble func_myelf_get_raid_status</span><br><span class="line">Dump of assembler code for function func_myelf_get_raid_status:</span><br><span class="line">   0x0000555555555199 &lt;+0&gt;:     movabs $0x7ffff7fbb2cc,%rax</span><br><span class="line">   0x00005555555551a3 &lt;+10&gt;:    jmp    *%rax</span><br><span class="line">   0x00005555555551a5 &lt;+12&gt;:    lea    0xe5c(%rip),%rax        # 0x555555556008</span><br><span class="line">   0x00005555555551ac &lt;+19&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00005555555551af &lt;+22&gt;:    call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555551b4 &lt;+27&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555551b8 &lt;+31&gt;:    movb   $0x0,(%rax)</span><br><span class="line">   0x00005555555551bb &lt;+34&gt;:    nop</span><br><span class="line">   0x00005555555551bc &lt;+35&gt;:    leave</span><br><span class="line">   0x00005555555551bd &lt;+36&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>func_glibc_write_data</code> 的代码段其实地址就是 <code>0x5555555551be</code>，与main函数中的call地址符合。但是可以注意到，这里面<code>write</code>的调用，显示的是plt表中的write。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble func_glibc_write_data</span><br><span class="line">   0x5555555551be &lt;func_glibc_write_data&gt;          push   %rbp                                              </span><br><span class="line">   0x5555555551bf &lt;func_glibc_write_data+1&gt;        mov    %rsp,%rbp                                         </span><br><span class="line">   0x5555555551c2 &lt;func_glibc_write_data+4&gt;        sub    $0x30,%rsp                                        </span><br><span class="line">   0x5555555551c6 &lt;func_glibc_write_data+8&gt;        movabs $0x2073692073696854,%rax                          </span><br><span class="line">   ...             </span><br><span class="line">   0x555555555255 &lt;func_glibc_write_data+151&gt;      call   0x555555555040 &lt;write@plt&gt;                        </span><br><span class="line">   0x55555555525a &lt;func_glibc_write_data+156&gt;      test   %rax,%rax                                         </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<hr>
<p>上面从汇编角度解释了为什么普通函数无法hook生效，我们接下来gdb调试看下write究竟是如何解析的。<br>准备工作：编译出glibc2.41产物，下面说的build目录下即为glibc安装后的所有产物。使用patchelf修改main程序的解释器。否则系统中的ld默认是不带符号的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ldd main</span>                                                                                              </span><br><span class="line">        linux-vdso.so.1 (0x00007ffce8d33000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f084a0a5000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f084a2bc000)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">patchelf --set-interpreter ./build/elf/ld.so ./main</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ldd main</span>                                                                                             </span><br><span class="line">        linux-vdso.so.1 (0x00007ffeae9fb000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5ad2d5f000)</span><br><span class="line">        ./build/elf/ld.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f5ad2f77000)</span><br></pre></td></tr></table></figure>

<p>准备开始调试main程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb main</span><br><span class="line"></span><br><span class="line">首先设备环境变量，LD_PRELOAD 及 LD_LIBRARY_PATH</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">set</span> environment LD_LIBRARY_PATH=./build</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">set</span> environment LD_PRELOAD=./preload.so</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">b func_glibc_write_data</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">r</span></span><br></pre></td></tr></table></figure>

<p>这是c代码，跳到了即将调入write前：<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128185814.png" alt="Pasted image 20260128185814.png"></p>
<p>这是汇编代码，我们单步进去。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190004.png" alt="Pasted image 20260128190004.png"></p>
<p>进来后，可以看到<code>plt表</code>里面的write部分的代码如下：准备先jmp <a href="mailto:&#119;&#x72;&#x69;&#x74;&#x65;&#x40;&#x67;&#111;&#x74;&#46;&#x70;&#108;&#x74;">write@got.plt</a>表里的存储的地址去执行。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190117.png" alt="Pasted image 20260128190117.png"></p>
<p>我们可以看到，此时的 <code>0x555555558008</code>存储的是<code>0x555555555046</code>，也就是说，上面的汇编代码是要去 <code>0x555555555046</code>去执行，也就是上面的 plt表里jmp的下一行代码。看起来感觉是啥也没干，跳了个寂寞。但是假设一下，如果 <code>0x555555558008</code>存储的是另外一个函数的代码段的地址呢？那就直接跳转过去执行了。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190328.png" alt="Pasted image 20260128190328.png"></p>
<p>那么跳回plt表的write的第二行，会push一个索引(是重定位表中需要重定位的符号的序号)，然后跳转到<code>0x555555555020</code>去执行。<code>0x555555555020</code>其实就是plt表项的首个结构，主要负责地址解析，跳转到ld的解析函数的。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190920.png" alt="Pasted image 20260128190920.png"></p>
<p>这里会先将<code>0x555555557ff0</code>的值push到栈，之前已经push过序号了，这里的这个值是它对应的link_map，然后跳转到0x7ffff7fd9610，这个代码地址在pmap中可以看到，其实是属于ld.so里的函数代码。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128215145.png" alt="Pasted image 20260128215145.png"><br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128215437.png" alt="Pasted image 20260128215437.png"><br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128231305.png" alt="Pasted image 20260128231305.png"></p>
<p>jmp后，可以看到，已经跳到ld.so的<code>_dl_runtime_resolve_xsavec</code>函数，这个在glibc中<code>/glibc-2.41/sysdeps/x86_64/dl-trampoline.h</code>是汇编代码实现的，主要逻辑如下所示。可以看出主要是调用了_dl_fixup，它传入了两个参数，%rdi: link_map, %rsi: reloc_index，正是我们调用过来是push栈上的两个值。而这个函数最后有个jmp，这里就是跳转到真实的函数地址处去执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _dl_runtime_resolve	_dl_runtime_resolve_xsavec</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	.globl _dl_runtime_resolve</span><br><span class="line">	.hidden _dl_runtime_resolve</span><br><span class="line">	.type _dl_runtime_resolve, @function</span><br><span class="line">	.align <span class="number">16</span></span><br><span class="line">	cfi_startproc</span><br><span class="line">_dl_runtime_resolve:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	# %rdi: link_map, %rsi: reloc_index</span><br><span class="line">	<span class="title function_">mov</span> <span class="params">(LOCAL_STORAGE_AREA + <span class="number">8</span>)</span><span class="params">(%BASE)</span>, %RSI_LP</span><br><span class="line">	mov <span class="title function_">LOCAL_STORAGE_AREA</span><span class="params">(%BASE)</span>, %RDI_LP</span><br><span class="line">	call _dl_fixup		# Call resolver.</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    jmp *%r11       # Jump to function address.</span><br><span class="line">	cfi_endproc</span><br><span class="line">	.size _dl_runtime_resolve, .-_dl_runtime_resolve</span><br></pre></td></tr></table></figure>


<p><code>_dl_fixup</code> 是用来做“延迟绑定（lazy binding）”的核心函数。函数代码太多，这里不再一一展开，只介绍下具体做了哪些事情：</p>
<ol>
<li>根据重定位表，及传入的重定位序号，拿到要查找哪个符号，及需要重定位回填的地址。</li>
<li>遍历 link_map 里查符号（真正 dlsym 那套），<code>_dl_lookup_symbol_x</code>函数中做的，每个elf&#x2F;so文件都会有一个link map结构，LD_PRELOAD的so是在其所有依赖的so(比如libc.so)之前加载的，所以它的link map在libc的link map前面，因此查符号时它里面的符号会被优先查找匹配到，从而直接返回了preload so里面的write函数的地址</li>
<li>计算最终写入地址</li>
<li>把结果写回 GOT表中(需要重定位回填的地址处)，<code>elf_machine_fixup_plt</code>函数中做的</li>
<li>返回函数地址，跳过去执行</li>
<li>函数返回到上层<code>_dl_runtime_resolve_xsavec</code>，去跳转到真正的目标函数处执行</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute((noinline)) DL_ARCH_FIXUP_ATTRIBUTE _dl_fixup(</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">    ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab = (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uintptr_t</span> pltgot = (<span class="type">uintptr_t</span>)D_PTR(l, l_info[DT_PLTGOT]);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc =</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset(pltgot, reloc_arg));</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM)(reloc-&gt;r_info)];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="type">lookup_t</span> result;</span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">    assert(ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY)(sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">                (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">           not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">           we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version,</span><br><span class="line">                                     ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">           of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">           offset.  */</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE(result, SYMBOL_ADDRESS(result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">           address) is also known.  */</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE(l, SYMBOL_ADDRESS(l, sym, <span class="literal">true</span>));</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">    value = elf_machine_plt_value(l, reloc, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(ELFW(ST_TYPE)(sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR(value));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Auditing checkpoint: we have a new binding.  Provide the auditing</span></span><br><span class="line"><span class="comment">       libraries the possibility to change the value and tell us whether further</span></span><br><span class="line"><span class="comment">       auditing is wanted.</span></span><br><span class="line"><span class="comment">       The l_reloc_result is only allocated if there is an audit module which</span></span><br><span class="line"><span class="comment">       provides a la_symbind.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;l_reloc_result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* This is the address in the array where we store the result of previous</span></span><br><span class="line"><span class="comment">           relocations.  */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span> *<span class="title">reloc_result</span> =</span></span><br><span class="line">            &amp;l-&gt;l_reloc_result[reloc_index(pltgot, reloc_arg, <span class="keyword">sizeof</span>(PLTREL))];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> init = atomic_load_acquire(&amp;reloc_result-&gt;init);</span><br><span class="line">        <span class="keyword">if</span> (init == <span class="number">0</span>) &#123;</span><br><span class="line">            _dl_audit_symbind(l, reloc_result, reloc, sym, &amp;value, result, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Store the result for later runs.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_likely(!GLRO(dl_bind_not))) &#123;</span><br><span class="line">                reloc_result-&gt;addr = value;</span><br><span class="line">                <span class="comment">/* Guarantee all previous writes complete before init is</span></span><br><span class="line"><span class="comment">                   updated.  See CONCURRENCY NOTES below.  */</span></span><br><span class="line">                atomic_store_release(&amp;reloc_result-&gt;init, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = reloc_result-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt(l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在call <code>_dl_fixup</code>之后，再看下write的got.plt表里面的数据，已经被<code>_dl_fixup</code>了修改了，原来是<code>0x555555555046</code>(plt表write的第二条指令的地址)。<br>现在是<code>0x7ffff7fbb109</code>，这个就是我们preload so里面的write函数的地址，因此以后再次调用write时，就不用再次跳到ld去解析，而是直接都跳转到preload so里面的write函数处了。<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128190328.png" alt="Pasted image 20260128190328.png"><br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128222639.png" alt="Pasted image 20260128222639.png"><br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128223006.png" alt="Pasted image 20260128223006.png"></p>
<h2 id="五、my-poor-inline-hook"><a href="#五、my-poor-inline-hook" class="headerlink" title="五、my poor inline hook"></a>五、my poor inline hook</h2><p>在第四节中，我们已经介绍了elf中普通函数失效的原因，以及preload能hook libc.so中函数的原因。那我们还有什么方法去实现hook elf中普通函数吗？<br>目前能想到的，就是直接使用inline hook(我们这里实现的很简陋，什么异常情况都没考虑，只实现了跳转，实际工程上的可能更复杂)。</p>
<p>我们在preload.so基础上，再写一个preload_inline_hook.so，代码如下。<br>主要的实现思路时：</p>
<ol>
<li>增加<code>__attribute__((constructor)) static void preload_init(void)</code>，在里面获取 <code>func_myelf_get_raid_status</code>函数的地址</li>
<li>更改目标函数地址内存页面属性为rwx(一般为r-x，没有w属性)。 </li>
<li>将目标函数的二进制代码改为 jmp 到 我们的hook函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;link.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存主程序 load bias */</span></span><br><span class="line"><span class="type">static</span> Elf64_Addr g_main_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">ssize_t</span> <span class="params">(*<span class="type">fn_write_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">fn_write_t</span> g_real_write = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== write hook ========== */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> msg[] = <span class="string">&quot;This is hook glibc write&#x27;s data message.\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> hook_msg[] = <span class="string">&quot;[hook write]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 避免递归：不要在这里 printf */</span></span><br><span class="line">    g_real_write(STDOUT_FILENO, hook_msg, <span class="keyword">sizeof</span>(hook_msg) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_real_write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========== hook ELF 的函数 ========== */</span></span><br><span class="line"><span class="comment">/* 注意参数类型和返回值必须一致 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_hook_myelf_get_raid_status</span><span class="params">(<span class="type">bool</span> *exception)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> hook_msg[] = <span class="string">&quot;[hook func_myelf_get_raid_status]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提示下 hook 成功了*/</span></span><br><span class="line">    g_real_write(STDOUT_FILENO, hook_msg, <span class="keyword">sizeof</span>(hook_msg) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模拟异常 */</span></span><br><span class="line">    *exception = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_page_rwx</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">void</span> *page_start = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr &amp; ~(pagesize - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mprotect(page_start, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC) != <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;mprotect&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只做简单inline hook，未考虑指令越界、跳回原函数功能 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">install_hook</span><span class="params">(<span class="type">void</span> *target_func, <span class="type">void</span> *hook_func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target_func || !hook_func)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__) || defined(__amd64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;Building for x86_64&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jump_code[<span class="number">12</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br><span class="line">    jump_code[<span class="number">1</span>] = <span class="number">0xB8</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)&amp;jump_code[<span class="number">2</span>] = (<span class="type">uint64_t</span>)hook_func;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">10</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    jump_code[<span class="number">11</span>] = <span class="number">0xE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__aarch64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;Building for arm64&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jump_code[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">0</span>] = <span class="number">0x50</span>;</span><br><span class="line">    jump_code[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">3</span>] = <span class="number">0x58</span>;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">5</span>] = <span class="number">0x02</span>;</span><br><span class="line">    jump_code[<span class="number">6</span>] = <span class="number">0x1F</span>;</span><br><span class="line">    jump_code[<span class="number">7</span>] = <span class="number">0xD6</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span> *)&amp;jump_code[<span class="number">8</span>] = (<span class="type">uint64_t</span>)hook_func;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;unsupported arch&quot;</span></span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    make_page_rwx(target_func);</span><br><span class="line">    <span class="built_in">memcpy</span>(target_func, jump_code, <span class="keyword">sizeof</span>(jump_code));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">phdr_cb</span><span class="params">(<span class="keyword">struct</span> dl_phdr_info *info, <span class="type">size_t</span> size, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// g_real_write(STDOUT_FILENO, info-&gt;dlpi_name, strlen(info-&gt;dlpi_name));</span></span><br><span class="line">    <span class="comment">// g_real_write(STDOUT_FILENO, &quot;\n&quot;, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这是 ELF/ld.so 约定的一部分，对于 主程序本身，它不是通过 dlopen 打开的，</span></span><br><span class="line"><span class="comment">     * 也没有一个 依赖路径名 意义上的 so 名字，因此表现为空串 */</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;dlpi_name == <span class="literal">NULL</span> || info-&gt;dlpi_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        g_main_base = info-&gt;dlpi_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 普通的，在 .dynsym 里找符号 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dlsym(<span class="literal">NULL</span>, symname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 /proc/self/exe 的 .symtab 里找符号 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    Elf64_Ehdr *eh;</span><br><span class="line">    Elf64_Shdr *sh;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *shstr;</span><br><span class="line">    Elf64_Sym *symtab = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> nsyms = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *section_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *symbol_name;</span><br><span class="line"></span><br><span class="line">    dl_iterate_phdr(phdr_cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, <span class="string">&quot;open exe failed\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;open exe failed\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fstat(fd, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, <span class="string">&quot;mmap failed\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;mmap failed\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eh = (Elf64_Ehdr *)<span class="built_in">map</span>;</span><br><span class="line">    sh = (Elf64_Shdr *)((<span class="type">char</span> *)<span class="built_in">map</span> + eh-&gt;e_shoff);</span><br><span class="line">    shstr = (<span class="type">char</span> *)<span class="built_in">map</span> + sh[eh-&gt;e_shstrndx].sh_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历节 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eh-&gt;e_shnum; i++) &#123;</span><br><span class="line">        section_name = shstr + sh[i].sh_name;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(section_name, <span class="string">&quot;.symtab&quot;</span>)) &#123;</span><br><span class="line">            symtab = (Elf64_Sym *)((<span class="type">char</span> *)<span class="built_in">map</span> + sh[i].sh_offset);</span><br><span class="line">            nsyms = sh[i].sh_size / <span class="keyword">sizeof</span>(Elf64_Sym);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(section_name, <span class="string">&quot;.strtab&quot;</span>)) &#123;</span><br><span class="line">            strtab = (<span class="type">char</span> *)<span class="built_in">map</span> + sh[i].sh_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symtab || !strtab) &#123;</span><br><span class="line">        munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历symtab上的所有符号信息 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nsyms; i++) &#123;</span><br><span class="line">        <span class="comment">/* 不是函数信息时，直接跳过*/</span></span><br><span class="line">        <span class="keyword">if</span> (ELF64_ST_TYPE(symtab[i].st_info) != STT_FUNC)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .strtab 是 .symtab 的名字的集合 */</span></span><br><span class="line">        symbol_name = strtab + symtab[i].st_name;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(symbol_name, symname)) &#123;</span><br><span class="line">            Elf64_Addr addr = g_main_base + symtab[i].st_value;</span><br><span class="line">            munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span> *)addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* strip后，不带 .symtab 的情况 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr3</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 暂不考虑 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"><span class="comment">/* 一般低版本gcc，很多普通全局符号会带进 .dynsym，但是高版本gcc普通全局符号不再带进 .dynsym，</span></span><br><span class="line"><span class="comment"> * 因此使用 dlsym 查不到，需要自己解析elf查地址，</span></span><br><span class="line"><span class="comment"> * 但是如果elf 在Makefile中 显式使用了 -rdynamic，那全局符号也会进 .dynsym，那可以直接dlsym找到</span></span><br><span class="line"><span class="comment"> * 但是我们做preload so不能假定elf是否指定了该参数，</span></span><br><span class="line"><span class="comment"> * 如果要查找的符号不能使用dlsym找到，那就有两种方式：</span></span><br><span class="line"><span class="comment"> * 1. 未strip过的，可以直接解析elf文件，在 .symtab 里查找符号地址，然后加上load_bias 就可以定位到其地址</span></span><br><span class="line"><span class="comment"> * 2. strip过的，没有 .symtab 节， */</span></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">supper_get_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr2 find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr2(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr3 find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr3(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">preload_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> dlerr_msg[] = <span class="string">&quot;[preload] dlsym func_myelf_get_raid_status failed\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr = supper_get_addr(<span class="string">&quot;func_myelf_get_raid_status&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr)</span><br><span class="line">        install_hook(addr, func_hook_myelf_get_raid_status);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g_real_write(STDOUT_FILENO, dlerr_msg, <span class="keyword">sizeof</span>(dlerr_msg) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">preload_fini</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>我们首先gdb main，设置环境变量如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set environment LD_PRELOAD=./preload_inline_hook.so</span><br></pre></td></tr></table></figure>

<p>因为我们这里的<code>install_hook</code>是在 <code>constructor</code> 中调用的，而它是在main函数执行之前就已经执行完了，所以如果我们直接挂main函数，这时去看，指令早就替换完，看不到实际的替换效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">preload_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> dlerr_msg[] = <span class="string">&quot;[preload] dlsym func_myelf_get_raid_status failed\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr = supper_get_addr(<span class="string">&quot;func_myelf_get_raid_status&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr)</span><br><span class="line">        install_hook(addr, func_hook_myelf_get_raid_status);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g_real_write(STDOUT_FILENO, dlerr_msg, <span class="keyword">sizeof</span>(dlerr_msg) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在gdb中下断点： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b preload_init</span><br><span class="line">b main</span><br><span class="line">r</span><br></pre></td></tr></table></figure>

<p>此时程序会执行到 <code>preload_init</code> 这里， 此时查看 <code>func_myelf_get_raid_status</code> 的汇编代码。可以看到，主要包括函数开栈过程、调用printf函数、给传入的rdi参数赋值为0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /r func_myelf_get_raid_status</span><br><span class="line">Dump of assembler code for function func_myelf_get_raid_status:</span><br><span class="line">   0x00005555555551a9 &lt;+0&gt;:     55                      push   %rbp</span><br><span class="line">   0x00005555555551aa &lt;+1&gt;:     48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   0x00005555555551ad &lt;+4&gt;:     48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   0x00005555555551b1 &lt;+8&gt;:     48 89 7d f8             mov    %rdi,-0x8(%rbp)</span><br><span class="line">   0x00005555555551b5 &lt;+12&gt;:    48 8d 05 4c 0e 00 00    lea    0xe4c(%rip),%rax        # 0x555555556008</span><br><span class="line">   0x00005555555551bc &lt;+19&gt;:    48 89 c7                mov    %rax,%rdi</span><br><span class="line">   0x00005555555551bf &lt;+22&gt;:    e8 6c fe ff ff          call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555551c4 &lt;+27&gt;:    48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555551c8 &lt;+31&gt;:    c6 00 00                movb   $0x0,(%rax)</span><br><span class="line">   0x00005555555551cb &lt;+34&gt;:    90                      nop</span><br><span class="line">   0x00005555555551cc &lt;+35&gt;:    c9                      leave</span><br><span class="line">   0x00005555555551cd &lt;+36&gt;:    c3                      ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<hr>
<p>然后我们在gdb中，再次执行<code>c</code>，此时程序会执行到main函数处，然后再次查看 <code>func_myelf_get_raid_status</code> 的汇编代码，可以发现，我们已经将原始函数的前12字节的机器码 <code>55 48 89 e5 48 83 ec 10 48 89 7d f8</code> 替换为了 <code>48 b8 cc b2 fb f7 ff 7f 00 00 ff e0</code>，也就是 将hook函数的地址，存到rax里，然后使用<code>jmp</code>跳转到hook函数执行，从而实现了简易版的 hook elf中的普通函数。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /r func_myelf_get_raid_status</span><br><span class="line">Dump of assembler code for function func_myelf_get_raid_status:</span><br><span class="line">   0x00005555555551a9 &lt;+0&gt;:     48 b8 cc b2 fb f7 ff 7f 00 00   movabs $0x7ffff7fbb2cc,%rax</span><br><span class="line">   0x00005555555551b3 &lt;+10&gt;:    ff e0                   jmp    *%rax</span><br><span class="line">   0x00005555555551b5 &lt;+12&gt;:    48 8d 05 4c 0e 00 00    lea    0xe4c(%rip),%rax        # 0x555555556008</span><br><span class="line">   0x00005555555551bc &lt;+19&gt;:    48 89 c7                mov    %rax,%rdi</span><br><span class="line">   0x00005555555551bf &lt;+22&gt;:    e8 6c fe ff ff          call   0x555555555030 &lt;puts@plt&gt;</span><br><span class="line">   0x00005555555551c4 &lt;+27&gt;:    48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555551c8 &lt;+31&gt;:    c6 00 00                movb   $0x0,(%rax)</span><br><span class="line">   0x00005555555551cb &lt;+34&gt;:    90                      nop</span><br><span class="line">   0x00005555555551cc &lt;+35&gt;:    c9                      leave</span><br><span class="line">   0x00005555555551cd &lt;+36&gt;:    c3                      ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>0x7ffff7fbb2cc</code> 其实就是我们的hook函数的代码段的地址，从而实现hook。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /r func_hook_myelf_get_raid_status</span><br><span class="line">Dump of assembler code for function func_hook_myelf_get_raid_status:</span><br><span class="line">   0x00007ffff7fbb2cc &lt;+0&gt;:     55                      push   %rbp</span><br><span class="line">   0x00007ffff7fbb2cd &lt;+1&gt;:     48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fbb2d0 &lt;+4&gt;:     48 83 ec 40             sub    $0x40,%rsp</span><br><span class="line">   0x00007ffff7fbb2d4 &lt;+8&gt;:     48 89 7d c8             mov    %rdi,-0x38(%rbp)</span><br><span class="line">   0x00007ffff7fbb2d8 &lt;+12&gt;:    48 b8 5b 68 6f 6f 6b 20 66 75   movabs $0x7566206b6f6f685b,%rax</span><br><span class="line">   0x00007ffff7fbb2e2 &lt;+22&gt;:    48 ba 6e 63 5f 6d 79 65 6c 66   movabs $0x666c65796d5f636e,%rdx</span><br><span class="line">   0x00007ffff7fbb2ec &lt;+32&gt;:    48 89 45 d0             mov    %rax,-0x30(%rbp)</span><br><span class="line">   0x00007ffff7fbb2f0 &lt;+36&gt;:    48 89 55 d8             mov    %rdx,-0x28(%rbp)</span><br><span class="line">   0x00007ffff7fbb2f4 &lt;+40&gt;:    48 b8 5f 67 65 74 5f 72 61 69   movabs $0x6961725f7465675f,%rax</span><br><span class="line">   0x00007ffff7fbb2fe &lt;+50&gt;:    48 ba 64 5f 73 74 61 74 75 73   movabs $0x7375746174735f64,%rdx</span><br><span class="line">   0x00007ffff7fbb308 &lt;+60&gt;:    48 89 45 e0             mov    %rax,-0x20(%rbp)</span><br><span class="line">   0x00007ffff7fbb30c &lt;+64&gt;:    48 89 55 e8             mov    %rdx,-0x18(%rbp)</span><br><span class="line">   0x00007ffff7fbb310 &lt;+68&gt;:    c7 45 ef 73 5d 0a 00    movl   $0xa5d73,-0x11(%rbp)</span><br><span class="line">   0x00007ffff7fbb317 &lt;+75&gt;:    48 8b 05 72 2d 00 00    mov    0x2d72(%rip),%rax        # 0x7ffff7fbe090 &lt;g_real_write&gt;</span><br><span class="line">   0x00007ffff7fbb31e &lt;+82&gt;:    48 85 c0                test   %rax,%rax</span><br><span class="line">   0x00007ffff7fbb321 &lt;+85&gt;:    75 1d                   jne    0x7ffff7fbb340 &lt;func_hook_myelf_get_raid_status+116&gt;</span><br><span class="line">   0x00007ffff7fbb323 &lt;+87&gt;:    48 8d 05 d6 0c 00 00    lea    0xcd6(%rip),%rax        # 0x7ffff7fbc000</span><br><span class="line">   0x00007ffff7fbb32a &lt;+94&gt;:    48 89 c6                mov    %rax,%rsi</span><br><span class="line">   0x00007ffff7fbb32d &lt;+97&gt;:    48 c7 c7 ff ff ff ff    mov    $0xffffffffffffffff,%rdi</span><br><span class="line">   0x00007ffff7fbb334 &lt;+104&gt;:   e8 c7 fd ff ff          call   0x7ffff7fbb100 &lt;dlsym@plt&gt;</span><br><span class="line">   0x00007ffff7fbb339 &lt;+109&gt;:   48 89 05 50 2d 00 00    mov    %rax,0x2d50(%rip)        # 0x7ffff7fbe090 &lt;g_real_write&gt;</span><br><span class="line">   0x00007ffff7fbb340 &lt;+116&gt;:   48 8b 0d 49 2d 00 00    mov    0x2d49(%rip),%rcx        # 0x7ffff7fbe090 &lt;g_real_write&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<hr>
<p>效果基本就是上面所示，我们看下在 <code>preload_init</code> 里是怎么做的。首先是调用了 <code>supper_get_addr</code>，该函数主要就是获取 <code>func_myelf_get_raid_status</code> 的所在代码段的具体地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">preload_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> dlerr_msg[] = <span class="string">&quot;[preload] dlsym func_myelf_get_raid_status failed\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr = supper_get_addr(<span class="string">&quot;func_myelf_get_raid_status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clang-format off */</span></span><br><span class="line"><span class="comment">/* 一般低版本gcc，很多普通全局符号会带进 .dynsym，但是高版本gcc普通全局符号不再带进 .dynsym，</span></span><br><span class="line"><span class="comment"> * 因此使用 dlsym 查不到，需要自己解析elf查地址，</span></span><br><span class="line"><span class="comment"> * 但是如果elf 在Makefile中 显式使用了 -rdynamic，那全局符号也会进 .dynsym，那可以直接dlsym找到</span></span><br><span class="line"><span class="comment"> * 但是我们做preload so不能假定elf是否指定了该参数，</span></span><br><span class="line"><span class="comment"> * 如果要查找的符号不能使用dlsym找到，那就有两种方式：</span></span><br><span class="line"><span class="comment"> * 1. 未strip过的，可以直接解析elf文件，在 .symtab 里查找符号地址，然后加上load_bias 就可以定位到其地址</span></span><br><span class="line"><span class="comment"> * 2. strip过的，没有 .symtab 节， */</span></span><br><span class="line"><span class="comment">/* clang-format on */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">supper_get_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr2 find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr2(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">&quot;find_symbol_addr3 find sym\n&quot;</span>;</span><br><span class="line">    addr = find_symbol_addr3(symname);</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, msg,</span><br><span class="line">                     <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>find_symbol_addr</code> 就是直接使用 <code>dlsym</code>，它会在 <code>.dynsym</code> 节里找符号信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 普通的，在 .dynsym 里找符号 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dlsym(<span class="literal">NULL</span>, symname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是高版本编译时，普通非导出的全局符号不放进 <code>.dynsym</code> 里，所以直接使用 <code>dlsym</code> 可能找不到函数的地址。因此可以尝试从elf文件的 <code>.symtab</code> 里找符号(前提是程序没有strip，还保留着 <code>.symtab</code> 节)。<br>可以看到，在 <code>find_symbol_addr2</code> 里：</p>
<ol>
<li>首先是通过<code>dl_iterate_phdr</code>，来传入一个回调函数 <code>phdr_cb</code>，在<code>phdr_cb</code>中，确定elf文件映射到进程虚拟地址空间的基地址。</li>
<li>然后是打开当前进程对应的程序文件，mmap到内存里，根据elf头，确定节头的偏移。然后遍历节头，查找<code>symtab</code> 和 <code>strtab</code>的偏移。</li>
<li>遍历symtab上的所有符号信息，与我们传入的符号信息做匹配。匹配成功后，它就是这个符号相对于程序基址的偏移。我们再让其加上真正的在进程虚拟地址空间的基址，就拿到了该符号在进程虚拟地址空间地址。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 /proc/self/exe 的 .symtab 里找符号 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    Elf64_Ehdr *eh;</span><br><span class="line">    Elf64_Shdr *sh;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *shstr;</span><br><span class="line">    Elf64_Sym *symtab = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> nsyms = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *section_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *symbol_name;</span><br><span class="line"></span><br><span class="line">    dl_iterate_phdr(phdr_cb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, <span class="string">&quot;open exe failed\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;open exe failed\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fstat(fd, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">        g_real_write(STDOUT_FILENO, <span class="string">&quot;mmap failed\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;mmap failed\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eh = (Elf64_Ehdr *)<span class="built_in">map</span>;</span><br><span class="line">    sh = (Elf64_Shdr *)((<span class="type">char</span> *)<span class="built_in">map</span> + eh-&gt;e_shoff);</span><br><span class="line">    shstr = (<span class="type">char</span> *)<span class="built_in">map</span> + sh[eh-&gt;e_shstrndx].sh_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历节 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eh-&gt;e_shnum; i++) &#123;</span><br><span class="line">        section_name = shstr + sh[i].sh_name;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(section_name, <span class="string">&quot;.symtab&quot;</span>)) &#123;</span><br><span class="line">            symtab = (Elf64_Sym *)((<span class="type">char</span> *)<span class="built_in">map</span> + sh[i].sh_offset);</span><br><span class="line">            nsyms = sh[i].sh_size / <span class="keyword">sizeof</span>(Elf64_Sym);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(section_name, <span class="string">&quot;.strtab&quot;</span>)) &#123;</span><br><span class="line">            strtab = (<span class="type">char</span> *)<span class="built_in">map</span> + sh[i].sh_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symtab || !strtab) &#123;</span><br><span class="line">        munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历symtab上的所有符号信息 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nsyms; i++) &#123;</span><br><span class="line">        <span class="comment">/* 不是函数信息时，直接跳过*/</span></span><br><span class="line">        <span class="keyword">if</span> (ELF64_ST_TYPE(symtab[i].st_info) != STT_FUNC)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .strtab 是 .symtab 的名字的集合 */</span></span><br><span class="line">        symbol_name = strtab + symtab[i].st_name;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(symbol_name, symname)) &#123;</span><br><span class="line">            Elf64_Addr addr = g_main_base + symtab[i].st_value;</span><br><span class="line">            munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">void</span> *)addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(<span class="built_in">map</span>, st.st_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>phdr_cb</code>，确定elf文件的基地址，一般就是pmap -x pid，看到的首个地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">phdr_cb</span><span class="params">(<span class="keyword">struct</span> dl_phdr_info *info, <span class="type">size_t</span> size, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// g_real_write(STDOUT_FILENO, info-&gt;dlpi_name, strlen(info-&gt;dlpi_name));</span></span><br><span class="line">    <span class="comment">// g_real_write(STDOUT_FILENO, &quot;\n&quot;, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这是 ELF/ld.so 约定的一部分，对于 主程序本身，它不是通过 dlopen 打开的，</span></span><br><span class="line"><span class="comment">     * 也没有一个 依赖路径名 意义上的 so 名字，因此表现为空串 */</span></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;dlpi_name == <span class="literal">NULL</span> || info-&gt;dlpi_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        g_main_base = info-&gt;dlpi_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strip后，不带 .symtab 的情况，这种情况比较复杂，暂未考虑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strip后，不带 .symtab 的情况 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">find_symbol_addr3</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 暂不考虑 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>查找到目标函数的地址后，就可以调用 <code>install_hook</code>，完成函数地址入口点修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="type">static</span> <span class="type">void</span> <span class="title function_">preload_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> dlerr_msg[] = <span class="string">&quot;[preload] dlsym func_myelf_get_raid_status failed\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_real_write)</span><br><span class="line">        g_real_write = (<span class="type">fn_write_t</span>)dlsym(RTLD_NEXT, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr = supper_get_addr(<span class="string">&quot;func_myelf_get_raid_status&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr)</span><br><span class="line">        install_hook(addr, func_hook_myelf_get_raid_status);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        g_real_write(STDOUT_FILENO, dlerr_msg, <span class="keyword">sizeof</span>(dlerr_msg) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>install_hook</code>中，只做了跳走的逻辑，没有做是否跳回原函数的逻辑。目前只考虑了 <code>x86_64</code> 和 <code>arm64</code> 的情况处理。<br>主要做的就是：</p>
<ol>
<li>确定当前架构，根据hook函数地址，构造jump_code</li>
<li>调用 <code>make_page_rwx</code>，将代码段地址改为<code>rwx</code>，因为默认代码段是不可写的。</li>
<li>将jump_code，写入到目标函数入口点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 只做简单inline hook，未考虑指令越界、跳回原函数功能 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">install_hook</span><span class="params">(<span class="type">void</span> *target_func, <span class="type">void</span> *hook_func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!target_func || !hook_func)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__) || defined(__amd64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;Building for x86_64&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jump_code[<span class="number">12</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br><span class="line">    jump_code[<span class="number">1</span>] = <span class="number">0xB8</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)&amp;jump_code[<span class="number">2</span>] = (<span class="type">uint64_t</span>)hook_func;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">10</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    jump_code[<span class="number">11</span>] = <span class="number">0xE0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__aarch64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;Building for arm64&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jump_code[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">0</span>] = <span class="number">0x50</span>;</span><br><span class="line">    jump_code[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">3</span>] = <span class="number">0x58</span>;</span><br><span class="line"></span><br><span class="line">    jump_code[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    jump_code[<span class="number">5</span>] = <span class="number">0x02</span>;</span><br><span class="line">    jump_code[<span class="number">6</span>] = <span class="number">0x1F</span>;</span><br><span class="line">    jump_code[<span class="number">7</span>] = <span class="number">0xD6</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span> *)&amp;jump_code[<span class="number">8</span>] = (<span class="type">uint64_t</span>)hook_func;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">warning</span> <span class="string">&quot;unsupported arch&quot;</span></span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    make_page_rwx(target_func);</span><br><span class="line">    <span class="built_in">memcpy</span>(target_func, jump_code, <span class="keyword">sizeof</span>(jump_code));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>make_page_rwx</code> 主要是获取addr所在页的起始地址，调用 <code>mprotect</code> 改变该页的属性为可读可写可执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_page_rwx</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">void</span> *page_start = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr &amp; ~(pagesize - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mprotect(page_start, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC) != <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;mprotect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了hook普通函数，可以我们的hook函数中，决定返回raid卡状态是否异常，而避免了去真正的制造异常的raid卡。</p>
<hr>
<p>效果如下：</p>
<ol>
<li>未preload<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225233.png" alt="Pasted image 20260128225233.png"></li>
<li>preload 普通版本<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225313.png" alt="Pasted image 20260128225313.png"></li>
<li>preload poor inline hook版本<br><img src="/2026/01/28/preload_and_poor_inline_hook/Pasted_image_20260128225334.png" alt="Pasted image 20260128225334.png"></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hook/" rel="tag"># hook</a>
              <a href="/tags/LD-PRELOAD/" rel="tag"># LD_PRELOAD</a>
              <a href="/tags/poor-inline-hook/" rel="tag"># poor_inline_hook</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/01/05/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%8E%A5%E6%94%B6ack/" rel="prev" title="TCP三次握手-接收ack">
                  <i class="fa fa-angle-left"></i> TCP三次握手-接收ack
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2025 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wangzhixin</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
